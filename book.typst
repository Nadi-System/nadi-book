#set document(title: "Network Analysis and Data Integration (NADI) Book")
#set document(author: ("Gaurav Atreya"))
#set heading(numbering: "1.", depth: 3)
#set page(paper: "us-letter")
#set text(size: 11pt)
#set text(font: "Noto Sans")
#set par(spacing:2em)
#set raw(syntaxes: "typst/task.sublime-syntax")
#set par(leading: .8em)

        #show heading: it => [
            #block(above: 2em, below: 2em, it)
        ]
#show link: it => {
  if type(it.dest) != str {
    underline(text(fill:green, it))
  }
  else {
    underline(text(fill:blue, it))
  }
}
#show ref: underline
#show ref: set text(green)
#show raw: set block(fill: luma(230), inset: 8pt, radius: 4pt, width: 100%)
#show outline.entry.where(level: 1):it => {
                                    v(11pt, weak: true)
                                   strong(it) 
                                }
#outline(depth: 2, indent: 2em)
#pagebreak()
= Preface
#par()[NADI is currently under active development. As such does not have stable API yet, and many of the concepts explained in this book might not work yet.]
#par()[If you still want to use it for your projects, please do them with the knowledge that the API might change in next versions, and you might have to keep it updated until the system is stable. If you have any problems with the program, or would like some new features, please make an github issue, we will try to accomodate it if it fits within the scope of the program.]
#pagebreak(weak: true)
= Acknowledgements
#par()[Thank you everyone who has been consistently testing this software throughout the development and providing feedbacks. Specially the members of Water System Analysis Lab in University of Cincinnati.]
== Funding
#par()[Grant: \#W912HZ-24-2-0049 Investigators: Ray, Patrick 09-30-2024 -- 09-29-2025 U.S. Army Corps of Engineers Advanced Software Tools for Network Analysis and Data Integration (NADI) 74263.03 Hold Level:Federal]
#pagebreak(weak: true)
= Why NADI?
#par()[Network Analysis amd Data Integration (NADI) System is a system of programs made to make network based data analysis easier and more accessible.]
#par()[It consists of multiple tools, that perform two important functions, network detection and network analysis. First part is done throuh the #strong[Geographic Information (GIS) Tool], while the second part is done using a #strong[Domain Specific Programming Language (DSPL)] called NADI Task system.]
#image("src/images/nadi-workflow-simple.png")
== Why use NADI System?
#par()[Hydrologic modeling involves the integration of diverse data to simulate complex (and often poorly understood) hydrological processes. The analysis of complex hydrological processes often requires using domain specific calculations, and the visual representation requires the creation of custom maps and plots. Both of which can be a repetitive and error-prone processes, diverting time from data interpretation and scientific inquiry. Efficient methods are needed to automate these tasks, allowing researchers to focus on higher-level analysis and translation of their findings.]
#par()[Current solution to that problem is to either use general purpose programming languages like Python, R, Julia, etc., or use domain specific software packages to increase the reliability of the tasks. Domain Specific Programming Languages (DSPLs) like the NADI Task system provides better syntax for domain specific tasks, while also are general purpose enough for users to extend it for their use cases. NADI System is trying to be the software framework that can connect those two by integrating with various softwares and providing a intuitive way to do network based data analysis.]
#par()[Some example functionality of NADI system includes:]
- Detection of upstream/downstream relationships from stream network,
- Network based programming using an extensible custom programming language,
- Interactive plots and reports generation,
- Import/export from/to various GIS data formats, etc.
=== Network Based Data Analysis
#par()[If you have data that are network based, like in case of data related to points in a river. NADI provides a text representation of the network that can be manually created with any text editor, or through NADI GIS tool.]
=== Task System
#par()[The Domain Specific Programming Language (DSPL) developed for network analysis in NADI makes network analysis simple and intutive. So, it is easier to understand, interpret and catch mistakes. While the NADI IDE has network visualization tools built in that can help you visualiza the network attributes for visual analysis.]
#par()[For example, implementing "cumulative sum of streamflow" in nadi:]
``````task
node<inputsfirst>.cum_sf = node.streamflow + sum(inputs.streamflow);
``````
#par()[The trying to do this in Python while making sure input nodes are run before the output. So you might have to write a recursive algorithm like this:]
``````python
def cum_sf(node):
	node.cum_sf = node.streamflow + sum([cum_sf(i) for i in node.inputs()])
	return node.cum_sf

cum_sf(network.outlet())
``````
#par()[While a common mistake people might make is to write a simple loop like this:]
``````python
for node in network.nodes():
    node.cum_sf = node.streamflow + sum(
	    [i.streamflow for i in node.inputs()]
	)
``````
#par()[Which doesn't make sure input nodes are run before output in this case, and can error out when some variables are not present. NADI provides special syntax for cases where you can make sure variables exist before running something.]
=== Extensibility
#par()[NADI has two types of plugin systems, which means users can write their own analysis in any programming language and have it interact with NADI through attributes, or they can write it in rust and have even more direct interaction.]
#pagebreak(weak: true)
= Who this book is for
#par()[This book has sections explaining the concepts of the NADI system, its developmental notes, user guide and developer guide.]
#par()[Hence it can be useful for people who:]
- Want to understand the concepts used in NADI,
- Want to use NADI system for their use case,
- Want to develop plugin system for NADI,
- Want to contribute to the NADI system packages, etc.
#par()[Although not intended, it might include resources and links to other materials related to Rust concepts, Geographical Information System (GIS) concepts, Hydrology concepts, etc. that people could potentially benefit from.]
#pagebreak(weak: true)
= How to use this book
#par()[You can read this book sequentially to understand the concepts used in the NADI system. And then go through the references sections for a specific use cases you want to get into the details of.]
#par()[If you are in a hurry, but this is your first time reading this book, at least read the #ref(<intro>) Core Concepts, then refer to the section you are interested in. #ref(<learn-examples>) Learn by Example]
=== Code Blocks
#par()[The code blocks will have example codes for various languages, most common will be #raw("string template"), #raw("task"), and #raw("rust") codes.]
#par()[String template and task have custom syntax highlights that is intended to make it easier for the reader to understand different semantic blocks.]
#par()[For #raw("task") scripts/functions, if relevant to the topic, they might have #raw("Results") block following immediately showing the results of the execution.]
#par()[For example:]
``````task
network load_file("./data/mississippi.net")
node[ohio] render("{_NAME:case(title)} River")
``````
#par()[Results:]
``````output
{
  ohio = "Ohio River"
}
``````
#par()[Task and Rust code block might also include lines that are needed to get the results, but hidden due to being irrelevant to the discussion. In those cases you can use the eye icon on the top right side of the code blocks to make them visible. Similarly use the copy icon to copy the visible code into clipboard.]
=== String Template Syntax Highlight
#par()[The syntax highlight here in this book makes it so that any unknown transformers will be marked for easy detection to mistakes.]
``````stp
This shows var = {var:unknown()}, {_var:case(title)}
``````
#par()[Besides this, the syntax highlight can help you detect the variables part (within #raw("{}")), lisp expression (within #raw("=()")), or commands (within #raw("$()")) in the template.]
#par()[Note: commands are disabled, so they won't run during template rendering process. But if you are rendering a template to run as a command, then they will be executed during that process.]
#pagebreak(weak: true)
= How to Cite
#par()[The sections below show you a bibliography entry in ASCE format, and BibTeX format that you can copy.]
=== Journal Papers: TODO
#par()[The papers are currently still being worked on, and will be added here when they are published.]
=== This book
#par()[You can cite the link to this book as follows Make sure to replace Accessed Data by today's date.]
#par()[Atreya, G. 2025. “Network Analysis and Data Integration (NADI).” Accessed May 1, 2025. https://nadi-system.github.io/.]
``````
@misc{PrefaceNetworkAnalysis,
  title = {Network {{Analysis}} and {{Data Integration}} ({{NADI}})},
  author = {Atreya, Gaurav},
  year = {2025},
  url = {https://nadi-system.github.io/},
  urldate = {2025-05-02}
}
``````
== Works using Nadi System
#par()[Atreya, G., G. Mandavya, and P. Ray. 2024. “Which came first? Streamgages or Dams: Diving into the History of Unaltered River Flow Data with a Novel Analytical tool.” H51L-0865.]
``````
@inproceedings{atreyaWhichCameFirst2024,
  title = {Which Came First? {{Streamgages}} or {{Dams}}: {{Diving}} into the {{History}} of {{Unaltered River Flow Data}} with a {{Novel Analytical}} Tool},
  shorttitle = {Which Came First?},
  booktitle = {{{AGU Fall Meeting Abstracts}}},
  author = {Atreya, Gaurav and Mandavya, Garima and Ray, Patrick},
  year = {2024},
  month = dec,
  volume = {2024},
  pages = {H51L-0865},
  urldate = {2025-06-03},
  annotation = {ADS Bibcode: 2024AGUFMH51L.0865A}
}
``````
#pagebreak(weak: true)

= Nadi System Setup     
== Introduction
#par()[NADI is group of software packages that facilitate network analysis and do data analysis on data related to network/nodes.]
#par()[NADI System consists of:]
#table(
	columns: 2,
	table.header(
   	 [Tool],
  	 [Description],
 	 ),
	 [Tool], [Description],
	 [NADI GIS], [Geographic Information (GIS) Tool for Network Detection],
	 [NADI Task System], [Domain Specific Programming Language],
	 [NADI Plugins], [Plugins that provide the functions in Task System],
	 [NADI library], [Rust and Python library to use in your programs],
	 [NADI CLI], [Command Line Interface to run NADI Tasks],
 	 [NADI IDE], [Integrated Development Environment to write/ run NADI Tasks],
)

#par()[The github repositories consisting of source codes:]
#table(
	columns:2,
	table.header([Repo], [Tool]),
	[#link("https://github.com/Nadi-System/nadi-gis")[nadi-gis]], [Nadi GIS],
	[#link("https://github.com/Nadi-System/nadi-system")[nadi-system]], [Nadi CLI/ IDE/ Core],
	[#link("https://github.com/Nadi-System/nadi-plugins-rust")[nadi-plugins-rust]], [Sample Plugins],
	[#link("https://github.com/Nadi-System/nadi-book")[nadi-book]], [Source for this Nadi Book],
)
==== NADI GIS
#par()[Geographic Information (GIS) Tool for Network Detection. The main purpose of the NADI GIS is to find the network connectivity between a set of points using a stream network (which can be developed from elevation models, or downloaded from national databases).]
#par()[NADI GIS can be used as a terminal command or QGIS plugin, refer to #ref(<installation-nadi-gis>) for how to install it.]
==== NADI Task System
#par()[Task System is a Domain Specific Programming Language (DSL) that is designed for river network analysis. This is the main core of the network analysis. This is included when you install NADI as a library, CLI or GUI.]
==== NADI Plugins
#par()[The functions available to call in the task system comes from plugins. There are many internal plugins with core functions already available, while users can load their own plugins for other functions.]
#par()[Refer to the plugins section of the book for more details on how to use plugins, how to write them and what to keep in mind while using them.]
==== NADI libraries
#par()[Rust and Python library to use in your programs. Rust library #raw("nadi_core") is available to download/use from #raw("cargo") with the command #raw("cargo add nadi_core").]
#par()[While Python library requires you to clone the repo and build it with #raw("maturin") (for now). Future plan for it includes publishing it in pypi.]
===== Rust Libraries
#par()[If you are not writing your own rust programs or plugins, you can skip this section.]
#par()[There are three rust libraries:]
#table(columns: 2, table.header([Library], [Use]),
[#raw("nadi_core")], [Core library with data types, and plugin structure],
[#raw("nadi_plugin")], [Rust Procedural macro library to write nadi plugins],
[#raw("string_template_plus")], [Library for string templates with variables],
)
#par()[Everything is loaded by #raw("nadi_core") so you don't need to load them separately.]
===== NADI Python
#par()[While using NADI from python library, you only have access to nadi data types (Node, Network, etc), and the plugin functions, which are enough for most cases as python language syntax, variables, loops etc will give you a lot of flexibility on how to do your own analysis. The python module is structured as follows:]
``````
nadi [contains Node, Network, etc]
 +-- functions
 | +-- node [contains node functions]
 | +-- network [contains network functions]
 | +-- env [contains env functions]
 +-- plugins
   +-- <plugin> [each plugin will be added here]
   | +-- node [contains node functions]
   | +-- network [contains network functions]
   | +-- env [contains env functions]
   +-- <next-plugin> and so on ...
``````
#par()[The functions are available directly through #raw("functions") submodule, or through each plugin in #raw("plugins") submodule. An example python script looks like this:]
``````python
import nadi
import nadi.functions as fn

net = nadi.Network("data/ohio.network")
for node in net.nodes:
    try:
        _ = int(node.name)
        node.is_usgs = True
        print(fn.node.render(node, "Node {_NAME} is USGS Site"))
    except ValueError:
        node.is_usgs = False
``````
#par()[This code shows how to load a network, how to loop through the nodes, and use python logic, or use nadi functions for the node and assign attributes.]
#par()[More detail on how to use NADI from python will be explained in NADI Python chapter.]
==== NADI CLI
#par()[Command Line Interface to run NADI Tasks.]
#par()[This can run nadi task files, syntax highlight them for verifying them, generate markdown documentations for the plugins. The documentations included in this book (#link("plugins/index.md")[Function List] and each plugin's page like #link("plugins/attrs.md")[Attributes Plugin #raw("attrs")]) are generated with that. The documentation on each plugin functions comes from their docstrings in the code, please refer to how to write plugins section of the book for details on that.]
#par()[The available options are shown below.]
``````
Usage: nadi [OPTIONS] [TASK_FILE]

Arguments:
  [TASK_FILE]  Tasks file to run; if `--stdin` is also provided this runs before stdin

Options:
  -C, --completion <FUNC_TYPE>   list all functions and exit for completions [possible values: node, network, env]
  -c, --fncode <FUNCTION>        print code for a function
  -f, --fnhelp <FUNCTION>        print help for a function
  -g, --generate-doc <DOC_DIR>   Generate markdown doc for all plugins and functions
  -l, --list-functions           list all functions and exit
  -n, --network <NETWORK_FILE>   network file to load before executing tasks
  -p, --print-tasks              print tasks before running
  -P, --new-plugin <NEW_PLUGIN>  Create the files for a new nadi_plugin
  -N, --nadi-core <NADI_CORE>    Path to the nadi_core library for the new nadi_plugin
  -s, --show                     Show the tasks file, do not do anything
  -S, --stdin                    Use stdin for the tasks; reads the whole stdin before execution
  -r, --repl                     Open the REPL (interactive session) before exiting
  -t, --task <TASK_STR>          Run given string as task before running the file
  -h, --help                     Print help
  -V, --version                  Print version
``````
==== NADI IDE
#par()[NADI Integrated Development Environment (IDE) is a Graphical User Interface (GUI) for the users to write/ run NADI Tasks.]
#par()[As seen in the image below, IDE consists of multiple components arranged in a tiling manner. You can drag them to move them around and build your own layout. When you start IDE it suggests you some layouts and what to open. You can use the buttons on the top right of each pane to:]
- change pane type
- vertically split current pane
- horizontally split current pane
- fullscreen current page/ restore layout if it's fullscreen
- close current pane
#image("src/images/ide-screenshot.png")
#par()[It has the following components:]
===== Text Editor
#par()[Open text files, edit and save them.]
#par()[It comes with syntax highlighting for most languages. And custom highlight for tasks and network files.]
#par()[For Tasks file, it can also show you function signatures on top so you can write tasks easily, knowing what arguments the function needs and what the default values are.]
#par()[While open inside IDE, it can also run the tasks by sending them to the terminal, or search help documentations on functions. Hover over the buttons on the top row to see which button does what, and the keyboard shortcut to use them as well.]
===== Terminal
#par()[Terminal is there so you can run NADI in a interactive session. Read Eval Print Loop (REPL) of NADI here is meant mostly to be used inside the IDE to evaluate the tasks from editor, but you can open it independently as well.]
===== Function Help
#par()[This is a GUI with the list of all available plugin functions. You can expand the sidebar on left to search and browse functions. You can filter by type of function (node, network, env) with the buttons. When you click a function you can read its documentation on the right side.]
#par()[Capabilities of the #raw("iced") GUI libraries are limited right now, so you cannot select or copy text from the help. Please refer to the documentation online to do that. Or generate the documentation locally using #raw("nadi-cli") tool.]
===== Network Viewer
#par()[This is a pane where network is visualized, this is a very basic visualization to see the connections and is not optimized for drawing. Please avoid using this pane (making it visible) in case of large networks as it takes a lot of computation to draw this each frame.]
===== Attribute Browser
#par()[When you click on a node on Network Viewer it will open/update showing the attributes of that node. There is no way to edit the attributes from here, which is intensional design as attributes should be assigned from tasks so that they are reproducible. For temporary assignments use the terminal.]
===== SVG Viewer
#par()[This is a basic utility that can open a SVG file from disk and visualize it. You can click the refresh button to re-read the same file. This is intended for a quick way to check the SVG saved/exported from tasks. This is not a full fledge SVG renderer, so open them in image viewers or browsers to see how it looks.]
=== Trivia
- Nadi means River in Nepali (and probably in many south asian languages).
- First prototype of NADI was Not Available Data Integration, as it was meant to be an algorithm to fill data gaps using network information, but it was modified to be more generic for many network related analysis.

== Installation
#par()[Nadi System is a suite of software packages each have different installation methods. Some of the packages are uploaded to #raw("crates.io") (rust) and #raw("pypi") (python).  For others, you can either get the compiled binaries from the Releases page of the github repo [windows]. Or you can get the source code using #raw("git"), and using #raw("cargo") build the packages [all OS].]
==== Packages
#par()[For #raw("nadi-py") you can use #raw("pip"):]
``````bash
pip install nadi-py
``````
#par()[For #raw("nadi-cli") you can use #raw("cargo"):]
``````bash
cargo install nadi
``````
=== Downloading Binaries
#par()[Goto the repo of each component and refer to the releases section for binaries of different versions.]
- #link("https://github.com/Nadi-System/nadi-system/releases")[nadi-system binaries]
- #link("https://github.com/Nadi-System/nadi-gis/releases")[nadi-gis binaries]
- #link("https://github.com/Nadi-System/nadi-plugins-rust/releases")[plugins binaries]
#par()[To setup the nadi-systm to load the plugins you have to place them inside the directory included in the #raw("NADI_PLUGIN_DIRS") environmental variable. Refer to your Operating System's documentation on how to set environemental variables.]
#par()[The binaries should be able to run directly without needing extra steps. If you get a security warnings because the binaries are not signed, you might have to ignore it.]
=== Building from Source
#par()[This is currently the preferred way of installing #raw("nadi-system") (and #raw("nadi-gis") for Linux and MacOS). Although it includes a bit more steps this makes sure the compiled program is compatible with your OS.]
==== Prerequisites
#par()[The prerequisites for building from source are:]
- #raw("git") [Optional]: to clone the repo, you can directly download zip from github
- #raw("cargo"): To build the binaries from source.
- #raw("gdal") [Optional]: Only for #raw("nadi_gis") binary and plugin.
#par()[To install #raw("git") refer to the instructions for your operating system from the #link("https://git-scm.com/downloads")[official page].]
#par()[For #raw("cargo") follow the instructions to install rust toolsets for your operating system from the #link("https://www.rust-lang.org/tools/install")[official page]]
#par()[Installing #raw("gdal") can be little complicated for windows. For Linux, use your package manager to install #raw("gdal") and/or #raw("gdal-dev") package. Mac users can also install #raw("gdal") using #link("https://brew.sh/")[#raw("homebrew")]. For windows, follow the instructions from #link("https://gdal.org/en/stable/download.html#windows")[official website], after installation you might have to make some changes to environmental variables to let #raw("cargo") know where your #raw("gdal") binaries/header files are for the compilation to be successful. More details will be provided in the NADI GIS section.]
#par()[If you use Linux or Mac (with homebrew), then the installation of prerequisites should be easy. But if you do not have the confidence to setup #raw("gdal") for compiling #raw("nadi_gis") use the binaries provided for them from the previous steps.]
==== NADI System
#par()[It will build the binaries for #raw("nadi"), #raw("nadi-ide"), #raw("nadi-help"), #raw("nadi-editor"), etc. #raw("nadi") is the command line interface to run nadi tasks, parse/validate syntax etc. While #raw("nadi-ide") is the program to graphically develop nadi tasks and run them.]
#par()[Assuming you have #raw("git") and #raw("cargo"),]
``````bash
git clone https://github.com/Nadi-System/nadi-system
cd nadi-system
cargo build --release
``````
#par()[To run one of the binary from nadi system, use the command #raw("cargo run") with binary name.]
#par()[For example, the following will run the #raw("nadi-ide"):]
``````bash
cargo run --release --bin nadi-ide
``````
#par()[The compiled binaries will be saved in the #raw("target/release") directory, you can copy them and distribute it. The binaries do not need any other files to run.]
#par()[The plugins files if present in the system are automatically loaded from #raw("NADI_PLUGIN_DIRS") environmental variable. Look into installing the plugin section below.]
#par()[Note: all programs will compile and run in Windows, Linux, and MacOS, while only #raw("nadi-cli") and #raw("mdbook-nadi") will run in Android (tmux). #raw("nadi-ide") and family need the GUI libraries that are not available for android (tmux) yet.]

==== NADI GIS <installation-nadi-gis>
#par()[NADI GIS uses #raw("gdal") to read/write GIS files, so it needs to be installed. Please refer to #link("https://gdal.org/en/stable/download.html")[gdal installation documentation] for that.]
===== Windows
#par()[First download compiled gdal from here:]
- https://www.gisinternals.com/sdk.php Then download clang from here:
- https://github.com/llvm/llvm-project/releases
#par()[Extract it into a folder, and then set environmental variables to point to that:]
- #raw("GDAL_VERSION"): Version of gdal e.g. '3.10.0'
- #raw("LIBCLANG_PATH"): Path to the #raw("lib") directory of #raw("clang")
- #raw("GDAL_HOME"): Path to the #raw("gdal") that has the subdirectories like #raw("bin"), #raw("lib"), etc.
#par()[You can also follow the errors from the rust compilers as you compile to set the correct variables.]
#par()[Finally you can get the source code and compile #raw("nadi-gis") with the following command:]
``````bash
git clone https://github.com/Nadi-System/nadi-gis
cd nadi-gis
cargo build --release
``````
#par()[This will generate the #raw("nadi-gis") binary and #raw("gis.dll") plugin in the #raw("target/release") folder, they need to be run along side the #raw("gdal") shared libraries (#raw(".dll")s). Place the binaries in the same folder as the #raw("dll")s from #raw("gdal") and run it. To use the #raw("gis.dll") plugin from #raw("nadi"), #raw("nadi-ide"), etc. same thing applies there, those binaries should be run with the #raw("gdal")'s #raw("dll")s to be able to load the #raw("gis") plugin.]
===== Linux and Mac
#par()[Assuming you have #raw("git"), #raw("cargo"), and #raw("gdal") installed in your system you can build it like this:]
``````bash
git clone https://github.com/Nadi-System/nadi-gis
cd nadi-gis
cargo build --release --features bindgen
``````
#par()[The #raw("bindgen") feature will link the #raw("nadi-gis") binary with the #raw("gdal") from your system. So that you do not have to distribute #raw("gdal") with the binary for your OS.]
#par()[If you do not have #raw("gdal") installed in your system, then you can still build the nadi-gis without the #raw("bindgen") feature. This will still require #raw("gdal") to be available and distributed with the binary.]
``````bash
cargo build --release
``````
===== QGIS Plugin
#par()[The #raw("nadi-gis") repo also contains the QGIS plugin that can be installed to run it through QGIS. The plugin will use the #raw("nadi-gis") binary in your #raw("PATH") if available. And it also contains the nadi plugin that can be loaded into the nadi system to import/export GIS files into/from the system.]
#par()[You can download the zip file for plugin from releases page, and use the "Install from Zip" option on QGIS plugins tab. Or copy the #raw("nadi") directory inside #raw("qgis") to your python plugin directory for qgis.]
#par()[Refer to the #link("https://docs.qgis.org/3.40/en/docs/training_manual/qgis_plugins/fetching_plugins.html")[QGIS plugins page] for more instructions. In future we are planning on publishing the plugin so that you can simply add it from QGIS without downloading from here.]
===== Nadi GIS Plugin
#par()[The nadi plugin on this repo provides the functions to import attributes, geometries from GIS files, and export them into GIS files.]
==== Nadi Plugins
#par()[Out of the two types of plugins, the executable plugins are just simple commands, they do not need to be installed along side nadi, just make sure the executables that you are using from #raw("nadi") can be found in path. A simple way to verify that is to try to run that from terminal and see if it works.]
#par()[The compiled plugins can be loaded by setting the #raw("NADI_PLUGIN_DIRS") environmental variable. The environment variable should be the path to the folder containing the nadi plugins (in #raw(".dll"), #raw(".so"), or #raw(".dylib") formats for windows, linux and mac). You can write your own plugins based on our examples and compile them.]
#par()[Officially available plugins are in the #raw("nadi-plugins-rust") directory.]
#par()[Assuming you have #raw("git") and #raw("cargo"),]
``````bash
git clone https://github.com/Nadi-System/nadi-plugins-rust
cd nadi-gis
cargo build --release
``````
#par()[The plugins will be inside the #raw("target/release") directory. Copy them to the #raw("NADI_PLUGIN_DIRS") directory for nadi to load them.]
#par()[You can take any one of the plugins as an example to build your own, or following the plugin development instructions from the plugins chapter.]

== Plugins
#par()[Plugins allow users to extend the use case of the Nadi System by adding more functions or scripts. User are expected to only use plugins from trusted sources, or develop it in-house. Although the compiled plugin functions have their code exposed in their documentation for the transparency purposes even if the source code is not available, always make sure the plugin you run are not malicious.]
#par()[There are two types of nadi plugins. Compiled plugins (shared libraries) are loaded dynamically from shared libraries, while executable plugins are called as shell commands. Refer to #ref(<intro-plugins>) of core concepts for more details.]
==== Compiled Plugins
#par()[Compiled plugins are shared libraries (#raw(".so") in linux, #raw(".dll") in windows, and #raw(".dylib") on macOS). They can be generated by compiling the nadi plugin in rust, or you can download the correct plugin for your OS and #raw("nadi_core") version from the plugin repositories. It is recommended to only use plugins from trusted source.]
#par()[To setup the nadi-systm to load the compiled plugins you have to place them inside the directory included in the #raw("NADI_PLUGIN_DIRS") environmental variable. Refer to your Operating System's documentation on how to set environemental variables.]
#par()[The compiled plugins are loaded when NADI is starting up, there is no way to #raw("hot load") or #raw("reload") the plugins, so you need to reopen the nadi program itself (CLI, IDE, etc) if you want to load new/updated plugin functions.]
#par()[Once the plugins are loaded, the functions are directly available from the nadi task system, they'll act similar to the internal plugin functions.]
==== Executable Plugins
#par()[Executable plugins are terminal commands, you set it up as you'd set any other terminal programs, by making sure the program is in #raw("PATH") and can be executed from terminal. Linux and Mac do them mostly by default, while in Windows you might have to check the box saying something along the lines of "include this in path" during installation, or manually edit the #raw("PATH") in "Environment Variables".]
#par()[For example, if you want to call python scripts, make sure you can run #raw("python --version") in terminal and get a response.]
#par()[You can also check it using the #raw("command") function:]
``````task
network command("python --version", echo=true)
network command("Rscript --version", echo=true)
network command("julia --version", echo=true)
``````
#par()[Results:]
``````output
$ python --version
Python 3.13.3

$ Rscript --version
Rscript (R) version 4.5.1 (2025-06-13)

$ julia --version
julia version 1.11.5
``````
#par()[Here we can see, the commands that ran successfully and returned a version are valid.]
#par()[To write scripts and run them from nadi refer to #link(<plugin-dev-exe-plugins>)[Executable Plugins] section on Plugin Developer Guide.]
#pagebreak(weak: true)
#pagebreak(weak: true)

= Network Detection     
== Nadi GIS
#par()[Nadi GIS is available as a CLI tool and QGIS plugin, the CLI tool has the following functions:]
``````
Usage: nadi-gis [OPTIONS] <COMMAND>

Commands:
  nid      Download the National Inventory of Dams dataset
  usgs     Download data from USGS NHD+
  layers   Show list of layers in a GIS file
  check    Check the stream network to see outlet, branches, etc
  order    Order the streams, adds order attribute to each segment
  network  Find the network information from streams file between points
  help     Print this message or the help of the given subcommand(s)

Options:
  -q, --quiet  Don't print the stderr outputs
  -h, --help   Print help
``````
#par()[The important functions are:]
- Download NID and USGS NHD+ data,
- Check stream network for validity of DAG (Directed Acyclic Graph) required for NADI,
- Stream ordering for visual purposes,
- Network detection between points of interest using the stream network
#par()[You can use the help command for each one of the subcommand for more help. For example, #raw("usgs") subcommand's help using #raw("nadi-gis help usgs") gets us:]
``````
Download data from USGS NHD+

Usage: nadi-gis usgs [OPTIONS] --site-no <SITE_NO>

Options:
  -s, --site-no <SITE_NO>
          USGS Site number (separate by ',' for multiple)

  -d, --data <DATA>
          Type of data (u/d/t/b/n)
          
          [upstream (u), downstream (d), tributaries (t), basin (b), nwis-site (n)]
          
          [default: b]

  -u, --url
          Display the url and exit (no download)

  -v, --verbose
          Display the progress

  -o, --output-dir <OUTPUT_DIR>
          [default: .]

  -h, --help
          Print help (see a summary with '-h')
``````
=== NADI QGIS
#par()[The QGIS plugin for nadi has a subset of the CLI functionality. It can be accessed from the Processing Toolbox.]
#figure(image("src/images/qgis-processing.png", width: 40%), caption: [QGIS Processing Toolbox])
#par()[You can run the tools from there and use the layers in QGIS as inputs. The QGIS plugin will first try to find #raw("nadi-gis") binary on your #raw("PATH") and use it, if not it'll try to use the binary provided with the plugins. It is preferred to have #raw("nadi-gis") available in #raw("PATH") and running without errors.]

== Example
#par()[The examples here will be given using QGIS plugin, and using the CLI tool both. CLI tool is great for quickly running things, and doing things in batch, while QGIS plugin will be better on visualization and manual fixes using other GIS tools.]
==== Using QGIS Plugin
#par()[First #strong[downloading the data] is done through the #raw("Download USGS Data") tool. As shown in the screenshot below, input the USGS site ID and the data type you want to download.]
#figure(image("src/images/qgis-download.png", width: 80%),caption: [QGIS Download])
#par()[You will need, #raw("tributaries") for the upstream tributaries for network, and #raw("nwis-site") will download the USGS NWIS sites upstream of the location. We will use those two for the example. If you have national data from other sources, you can use the basin polygon to crop them.]
#par()[#strong[Stream Order] tool is mostly for visual purposes. The figure below shows the results from stream order on right compared to the raw download on left.]
#figure(image("src/images/qgis-order.png", width: 80%),caption: [Stream Order Result])
#par()[After you have streams (tributaries), you can use the #strong[Check Streams] tool to see if there are any errors. It will give all the nodes and their categories, you can filter them to see if it has branches, or if it has more than one outlet. The figure below shows the branches with red dot. If we zoom in we can see how the bifurcation on the stream is detected, and how stream order calculation is confused there.]
#figure(image("src/images/qgis-branch.png"),caption: [Check Streams Result])
#par()[#strong[Find Connections] tool will find the connection between the points using the stream network. The results below shows the tool being run on the NWIS points.]
#figure(image("src/images/qgis-network.png"),caption:[Find Connections Result])
#par()[If we select #strong[simplify] option, it'll only save the start and end point of the connection instead of the whole stream.]
#figure(image("src/images/qgis-network2.png"),caption: [Find Connections Result Alt])
#par()[Of course you can run #strong[Stream Order] on the results to get a more aesthetically pleasing result.]
#figure(image("src/images/qgis-network3.png"),caption: [Find Connections Result with Order])
==== Using CLI
#par()[An example of running #raw("nadi-gis") using CLI can be done in the following steps:]
===== Download data
#par()[We'll download the streamlines and the NWIS Sites from USGS for station 03217200 (Ohio River at Portsmouth, OH).]
``````bash
nadi-gis usgs -s 03217200 -d n -d t -o output/
``````
#par()[This will download two files:]
``````
output/03217200_nwis-site.json  output/03217200_tributaries.json
``````
#par()[Now we can use #raw("check") command to see if there are any problems with the streams.]
``````bash
nadi-gis check output/03217200_tributaries.json
``````
#par()[That gives us the following output:]
``````
Invalid Streams File: Branches (826)
* Outlet: 1
* Branch: 826
* Confluence: 30321
* Origin: 29591
``````
#par()[We can generate a GIS file to locate the branches and see if those are significant. Refer to the #raw("help") for #raw("check") or use the QGIS plugin.]
#par()[And to find the connections, we use #raw("network") subcommand like this:]
``````bash
nadi-gis network -i output/03217200_nwis-site.json output/03217200_tributaries.json
``````
#par()[Output:]
``````
Outlet: 3221 (-82.996916801, 38.727624498) -> None
3847 -> 3199
2656 -> 2644
399 -> 1212
2965 -> 3942
2817 -> 6236
5708 -> 4733
2631 -> 5741
201 -> 2101
2066 -> 2317
3770 -> 1045
... and so on
``````
#par()[Since this is not as useful, we can use the flags in the #raw("network") subcommand to use a different id, and save the results to a network file.]
#par()[First we can use #raw("layers") subcommand to see the available fields in the file:]
``````bash
nadi-gis layers output/03217200_nwis-site.json -a
``````
#par()[which gives us:]
``````
03217200_nwis-site
  - Fields:
    + "type" (String)
    + "source" (String)
    + "sourceName" (String)
    + "identifier" (String)
    + "name" (String)
    + "uri" (String)
    + "comid" (String)
    + "reachcode" (String)
    + "measure" (String)
    + "navigation" (String)
``````
#par()[Using #raw("comid") as the id for points, and saving the results:]
``````bash
nadi-gis network -i output/03217200_nwis-site.json output/03217200_tributaries.json -p comid -o output/03217200.network
``````
#par()[The #raw("output/03217200.network") file will have the connections like:]
``````
15410797 -> 15411587
6889212 -> 6890126
8980342 -> 10220188
19440469 -> 19442989
19390000 -> 19389366
6929652 -> 6929644
... and so on
``````
#par()[Make sure you use a field with unique name, and valid identifier in NADI System.]
#pagebreak(weak: true)
#pagebreak(weak: true)

= Network Analysis      
== Core Concepts <intro>
#par()[This section contains a brief explanation of core concepts.]
#par()[The main concepts that you need to know are:]
- #par()[#strong[Attributes] are values, it can be float, integer, boolean, strings, or list of attributes, or a map of attributes (key=value),]

- #par()[#strong[Nodes] are points in the network, they can have attributes, input nodes and an output node,]

- #par()[#strong[Network] is a collection of nodes, network can also have attributes, Network used in the Nadi system can have only one outlet, so a 'ROOT' node is added if there are multiple outlet. And loading a network that is not a directed tree is undefined behaviour.]

- #par()[#strong[Expression] is something that can be evaluated or executed, it consists of literal values (attributes), variables (node, network, env variables that could hold attributes), function calls, or a mathmatical or logical operation.]

- #par()[#strong[Functions] in nadi are of 3 types, env functions are normal functions that take values and run, network functions take values and run on the network, while node functions run at each node (they also provide a way to subset which nodes to run it on).]

- #par()[#strong[Task] is an execution body of the task system. It can be of env, network or node type. It can be conditional (If-Else) or loop (While) consisting of more tasks inside it. Task can assign values to the env/network/node attributes, or call mutable functions on the top level.]

- #par()[#strong[String Template]: Some functions take string inputs that are interpreted dynamically to represent different strings based on variables.]

- #par()[#strong[Plugins] provide the functions used by the nadi task system. There are internal plugins and external plugins. Internal plugins comes with the installation, while external plugins are loaded from dynamic libraries.]

==== Keywords
#table(columns: 2, table.header([Keyword], [Description]),
[node], [the node task type, function or variable],
[network/net], [the network task type, function or variable],
[env], [the environment task type, function or variable],
[exit], [exit the program],
[end], [end the execution of tasks without exiting],
[help], [display help for functions],
[inputs], [get node variables or function output for input nodes of a node],
[output], [get node variable or function output for output node of a node],
[nodes], [get node variable or function output for all nodes in the network],
[if], [if statement for conditional task/expression],
[else], [else statement for conditional task/expression],
[while], [while statement for loop task],
[in], [binary operator to check if something is in another (list/string)],
[match], [binary operator to check patterns on string (regex)],
)
#par()[And here are some keywords reserved for future:]
#table(columns: 2, table.header([Keyword], [Description]),
[function/func], [user defined functions],
[map], [map values in an array/attrmap to a function],
[attrs], [attributes of the env/node/network],
[loop], [loop task],
[for], [for loop task for looping through array/attrmap],
)
#par()[Continue with the chapters for details on each concept. Or skip ahead to #link(<learn-examples>)[Learn by Examples] if you want to jump into the examples.]
== Task
#par()[Task is an execution body in the task system. There are different types of tasks, specially environment, network and node type tasks, and there can be conditional tasks that only execute based on a condition or loops.]
#par()[Some examples of different tasks are given below to show a general overview, but the concepts inside the tasks system will be introduced as we progress through the chapters,]
#par()[Environment tasks that can evaluate expressions, assign variables, or call functions:]
``````task
env 1 + 2 * 8
env render("my name is {_name}", name="John")
env.x = 12 > 2;
env.x
``````
#par()[Results:]
``````output
17
"my name is John"
true
``````
#par()[network task loading a network, and node task getting node attributes:]
``````task
network load_str("a->b\nb->c")
node.NAME
``````
#par()[Results:]
``````output
{
  c = "c",
  b = "b",
  a = "a"
}
``````
#par()[Conditional and Loop task]
``````task
if ( !val? | (val > 5) ) {
	# if val is not defined or greater than 5, set it to 0
    env.val = 0
}
while (val < 5) {
	env.val = env.val + 1
}
``````
#par()[Results:]
``````output
0 -> 1
1 -> 2
2 -> 3
3 -> 4
4 -> 5
``````
#par()[Tasks system acts like a scripting language for nadi system. A Task consists of getting/evaluating/setting attributes in environment, network or nodes. The value that can be evaluated are expressions that consists of literal values, variables, or function calls that can either be a environment, node or a network function. Functions are unique based on their names, and can have default values if users do not pass all arguments.]
#par()[The code examples throughout this book, that are being used to generate network diagrams, tables, etc are run using the task system.]
#par()[Here is an example contents of a more complex task file, do not concern with what each task does, we will go through them in other chapters.]
``````task
# sample .tasks file which is like a script with functions
node<inputsfirst> print_attrs("uniqueID")
node show_node()
network save_graphviz("/tmp/test.gv")
node<inputsfirst>.cum_val = node.val + sum(inputs.cum_val);

node[WV04113,WV04112,WV04112] print_attr_toml("testattr2")
node render("{NAME} {uniqueID} {_Dam_Height_(Ft)?}")
node list_attr("; ")
# some functions can take variable number of inputs
network calc_attr_errors(
    "Dam_Height_(Ft)",
    "Hydraulic_Height_(Ft)",
    "rmse", "nse", "abserr"
)
node sum_safe("Latitude")
node<inputsfirst> render("Hi {SUM_ATTR}")
# multiple line for function arguments
network save_table(
	"test.table",
	"/tmp/test.tex",
	true,
	radius=0.2,
	start = 2012-19-20,
	end = 2012-19-23 12:04
	)
node.testattr = 2
node set_attrs_render(testattr2 = "{testattr:calc(+2)}")
node[WV04112] render("{testattr} {testattr2}")

# here we use a complicated template that can do basic logic handling
node set_attrs_render(
    testattr2 = "=(if (and (st+has 'Latitude) (> (st+num 'Latitude) 39)) 'true 'false)"
)
# same thing can be done if you need more flexibility in variable names
node load_toml_string(
    "testattr2 = =(if (and (st+has 'Latitude) (> (st+num 'Latitude) 39)) 'true 'false)"
)
# selecting a list of nodes to run a function
node[
	# comment here?
    WV04113,
    WV04112
] print_attr_toml("testattr2")
# selecting a path
node[WV04112 -> WV04113] render("=(> 2 3)")
``````

== Attributes
#par()[Attributes are #link("https://toml.io/en/")[TOML] like values. They can be one of the following types:]
#table(columns: 3, table.header(
[Type Name], [Rust Type], [Description]
),
[Bool], [#raw("bool")], [Boolean values (#raw("true") or #raw("false"))],
[String], [#raw("RString")], [Quoted String Values],
[Integer], [#raw("i64")], [Integer values (numbers)],
[Float], [#raw("f64")], [Float values (numbers with decimals)],
[Date], [#raw("Date")], [Date (#raw("yyyy-mm-dd") formatted)],
[Time], [#raw("Time")], [Time (#raw("HH:MM"), #raw("HH:MM:SS") formatted)],
[DateTime], [#raw("DateTime")], [Date and Time separed by #raw(" ") or #raw("T")],
[Array], [#raw("RVec<Attribute>")], [List of any attribute values],
[Table/AttrMap], [#raw("AttrMap")], [Key Value pairs of any attribute values],
)
#par()[You can write attributes directly into the task system to assign them, use them in functions. You can also load attributes from a file into the env/node/network.]
#par()[If you want to assign a attribute inside the task system, you can do it like this:]
``````task
env.river = "Ohio River"
env.river
``````
#par()[Results:]
``````output
"Ohio River"
``````
#par()[Example Attribute File that can be loaded:]
``````toml
river = "Ohio River"
outlet = "Smithland Lock and Dam"
outlet_is_gage = true
outlet_site_no = ""
streamflow_start = 1930-06-07
mean_streamflow = 123456.0
obs_7q10 = 19405.3
nat_7q10 = 12335.9
num_dams_gages = 2348
``````
#par()[Here loading the files we can see only ohio has the attributes loaded]
``````task
! network load_file("./data/mississippi.net")
node[ohio] load_attrs("./data/attrs/{_NAME}.toml")
node.outlet
``````
#par()[Results:]
``````output
{
  lower-mississippi = <None>,
  upper-mississippi = <None>,
  missouri = <None>,
  arkansas = <None>,
  red = <None>,
  ohio = "Smithland Lock and Dam",
  tenessee = <None>
}
``````
#par()[With plugins, you can load attributes from different file types.]

== Node
#par()[A Node is a point in network. A Node can have multiple input nodes and only one output node. And a Node can also have multiple attributes identifiable with their unique name, along with timeseries values also identifiable with their names.]
#par()[If you understand graph theory, then node in nadi network is the same as a node in a graph.]
#par()[Nodes in Nadi are identified by their name, that is loaded from the network file. Node names are string values, even if they are integer or float, they are read and internally stored as strings. If the node name contains characters outside of alphanumeric and underscore (#raw("_")), it has to be quoted.]
#par()[i.e. valid names like #raw("123") or #raw("node_1") can appear unquoted or quoted, but names like #raw("node-123") needs to be quoted: #raw("\"node-123\"").]
``````task
network load_str("
123 -> node_1
node_1 -> \"node-123\"
")
node.NAME
``````
#par()[Results:]
``````output
{
  node-123 = "node-123",
  node_1 = "node_1",
  123 = "123"
}
``````
#par()[If you do not quote the name, you'll get an error:]
``````task
network load_str("123 -> node-1")
node.NAME
``````
#par()[\*Error\*:]
``````error
Error in function load_str: Error: Parse Error at Line 1 Column 8
  123 -> node-1
         ^ Incomplete Path; expected node here
``````

== Network
#par()[A Network is a collection of nodes. The network can also have attributes associated with it. The connection information is stored within the nodes itself. But Network will have nodes ordered based on their connection information. So that when you loop from node from first to last, you will always find output node before its input nodes.]
#par()[A condition a nadi network is that it can only be a directed graph with tree structure.]
#par()[Example Network file:]
``````net
# network consists of edges where input node goes to output node
# each line is of the format: input -> output
tenessee -> ohio
# if your node name has characters outside of a-zA-Z_, you need to
# quote them as strings
ohio -> "lower-mississippi"
"upper-mississippi" -> "lower-mississippi"
missouri -> "lower-mississippi"
arkansas -> "lower-mississippi"
red -> "lower-mississippi"
``````
#par()[The given network can be loaded and visualized using #raw("svg_save") function.]
``````task
network load_file("./data/mississippi.net")
network command("mkdir -p output")
network svg_save(
   "./output/network-mississippi.svg",
	label="[{INDEX}] {_NAME:repl(-, ):case(title)}",
	bgcolor="gray"
)
``````
#par()[Results:]
#align(center,image("./src/output/network-mississippi.svg"))
#par()[You can assign different graphical properties through node properties.]
``````task
network load_file("./data/mississippi.net")
node[red].visual.nodecolor = "red";
node[ohio].visual.linecolor = "blue";
node[ohio].visual.linewidth = 3;
node["upper-mississippi", red].visual.nodesize = 8;
node[red].visual.nodeshape = "triangle";
node["upper-mississippi"].visual.nodeshape = "ellipse:0.5";
network svg_save(
   "./output/network-mississippi-colors.svg",
   label="[{INDEX}] {_NAME:repl(-, ):case(title)}",
	bgcolor="gray"
)
``````
#par()[Results:]
#align(center, image("./src/output/network-mississippi-colors.svg"))

== Expression
#par()[Expressions are airthmetic or logical operations. They can appear inside the conditional statements, or as input to a task, or nested in other expression or function calls.]
#par()[Expressions are defined into the following categories:]
==== Literal Values
``````task
env [1, true, "no maybe"]
``````
#par()[Results:]
``````output
[1, true, "no maybe"]
``````
==== Variable
``````task
env.value = [1, true, "no maybe"];
env.value
``````
#par()[Results:]
``````output
[1, true, "no maybe"]
``````
#par()[Variables also have a "check" mode, where it returns true if variable exists, false if it does not.]
``````task
env.value = [1, true, "no maybe"];
env value?
env other_var?
``````
#par()[Results:]
``````output
true
false
``````
#par()[You can also use use varible from node, or network in other context. For example:]
``````task
env.value = [1, true, "no maybe"];
network echo(json(env.value))
``````
#par()[Results:]
``````output
[1, true, "no maybe"]
``````
#par()[Special variable types like #raw("nodes"), #raw("inputs"), #raw("output") are available besides #raw("env"), #raw("network") and #raw("node") based on what type of task the expression is on.]
#par()[You will learn more about this on #link(<intro-cross-context>)[Cross Context Functions and Variables] chapter.]
==== Unary Operator
``````task
env !true
env - 12.0
``````
#par()[Results:]
``````output
false
-12
``````
==== Binary Operator
``````task
env (12 > 34) & true
env "x" in "xyz"
env 12 in [123, true]
env "my name is" match "^my.*"
``````
#par()[Results:]
``````output
false
true
false
true
``````
==== If Else
``````task
env if(!true) {"if true"} else {"if false"}
``````
#par()[Results:]
``````output
"if false"
``````
==== Function
``````task
env.value = [1, true, "no maybe"];
env get(value, 2)
``````
#par()[Results:]
``````output
"no maybe"
``````
#par()[Out of all expressions, only the function is not garanteed to return a value. If you are using a function expression and expect a value and it does not return it, it'll be a runtime error.]
``````task
env echo("Hello world!") + 12
``````
#par()[\*Error\*:]
``````error
Hello world!

Function echo did not return a value
``````
#par()[Special function types like #raw("nodes"), #raw("inputs"), #raw("output") are available besides #raw("env"), #raw("network") and #raw("node") based on what type of task the expression is on.]
#par()[You will learn more about this on #link(<intro-cross-context>)[Cross Context Functions and Variables] chapter.]

== String Template
#par()[String templates are strings with dynamic components that can be rendered for each node based on the node attributes.]
#par()[A simple template can be like below:]
``````stp
Hi, my name is {name}, my address is {address?"N/A"}.
I wrote this document on {%A}, exact date: {%Y-%m-%d}.
``````
#par()[Results (with:  name=John; address=123 Road, USA):]
``````output
Hi, my name is John, my address is 123 Road, USA.
I wrote this document on Friday, exact date: 2025-06-20.
``````
#par()[With more complicated templates, we would be able to generate documents with text and images based on the node attributes as well.]
#par()[For example the following template can be used to generate a table.]
``````markdown
| Name             | Index   |
|------------------|---------|
<!-- ---8<--- -->
| {_NAME:case(up)} | {INDEX} |
<!-- ---8<--- -->
``````
``````task
network load_file("./data/mississippi.net");
network echo(render_template("./data/example.template"))
``````
#par()[Results:#linebreak()
|Name|Index| |----|-----| |LOWER-MISSISSIPPI|0| |UPPER-MISSISSIPPI|1| |MISSOURI|2| |ARKANSAS|3| |RED|4| |OHIO|5| |TENESSEE|6|]
#par()[Of course, there are better ways to generate table than this, but this shows how flexible the template system is.]

== Node Function
#par()[Node function runs on each node. It takes arguments and keyword arguments.]
#par()[For example following node function takes multiple attribute names and prints them. The signature of the node function is #raw("print_attrs(*args)").]
``````task
network load_file("./data/mississippi.net")
node print_attrs("INDEX", name=false)
``````
#par()[Results:]
``````output
INDEX = 0
INDEX = 1
INDEX = 2
INDEX = 3
INDEX = 4
INDEX = 5
INDEX = 6
``````
#par()[Only the #raw("NAME") is printed as they do not have any other attributes.]
==== Selective Execution
#par()[You can selectively run only a few nodes, or change the order the nodes are executed.]
#par()[Given this network:]
#par()[Network Diagram]
===== Inverse Order
``````task
network load_file("./data/mississippi.net")
node<inverse> print_attrs("NAME")
``````
#par()[Results:]
``````output
NAME = "tenessee"
NAME = "ohio"
NAME = "red"
NAME = "arkansas"
NAME = "missouri"
NAME = "upper-mississippi"
NAME = "lower-mississippi"
``````
==== List of Nodes
``````task
network load_file("./data/mississippi.net")
node[tenessee,"lower-mississippi"] print_attrs("NAME")
``````
#par()[Results:]
``````output
NAME = "lower-mississippi"
NAME = "tenessee"
``````
==== Path of Nodes
``````task
network load_file("./data/mississippi.net")
node[tenessee -> "lower-mississippi"] print_attrs("NAME")
``````
#par()[Results:]
``````output
NAME = "tenessee"
NAME = "ohio"
NAME = "lower-mississippi"
``````
#par()[As we can see in the diagram, the path from tenessee to lower mississippi includes the ohio node.]

== Network Function
#par()[Network function runs on the network as a whole. It takes arguments and keyword arguments. Few network functions we have been using throughout the examples are #raw("load_file"), #raw("load_str") and #raw("svg_save"):]
``````task
network load_file("./data/mississippi.net")
network command("mkdir -p output")
network svg_save(
   "./output/network-mississippi-sdf.svg",
	label="[{INDEX}] {_NAME:repl(-, ):case(title)}",
	bgcolor="gray"
)
``````
#par()[Results:]
#align(center, image("./src/output/network-mississippi-sdf.svg"))
#par()[For example following network function takes file path as input to save the network in graphviz format:]
``````sig
save_graphviz(
	outfile [PathBuf],
	name [String] = "network",
	global_attrs [String] = "",
	node_attr [Option < Template >],
	edge_attr [Option < Template >]
)
``````
#par()[Note that, if the arguments have default values, or are optional, then you do not need to provide them.]
#par()[For example, you can simply call the above function like this.]
``````task
network load_file("./data/mississippi.net")
network save_graphviz("./output/test.gv")
network clip()
# the path link are relative to /src
network echo("./output/test.gv")
``````
#par()[Results:]
``````output
digraph network {

"upper-mississippi" -> "lower-mississippi"
"missouri" -> "lower-mississippi"
"arkansas" -> "lower-mississippi"
"red" -> "lower-mississippi"
"ohio" -> "lower-mississippi"
"tenessee" -> "ohio"
}
``````
#par()[With extra commands you can also convert it into an image]
``````task
network load_file("./data/mississippi.net")
network save_graphviz("./output/test.gv")
network command("dot -Tsvg ./output/test.gv -o ./output/test.svg")
``````
#par()[Results:]
#align(center, image("./src/output/test.svg"))

== Cross Context Functions and Variables <intro-cross-context>
#par()[You can access variable and call functions based on their default context (e.g. node variable/function in a node task). Additionally, you can also access the variables or call functions in select few other context.]
#par()[By default, if a function is not available, node/network task calls the environment function of the same name.]
#par()[For example, here the #raw("sum") and #raw("array") functions are environment functions, while the #raw("count") is a network function. When you use Nadi IDE, it'll show you which function is actually being called at the top of the editor.]
``````task
network load_str("a->b")
network sum(array(count(), 1))
``````
#par()[Results:]
``````output
3
``````
#par()[Besides this, you can manually call cross context variable/functions in the following ways:]
==== Env and Network Variables/Functions
#par()[You can use #raw("env") and #raw("network") variables anywhere in the task system with the dot syntax.]
``````task
network load_str("a->b")
env.var = 12;
network.sth = true;

env render("this is {x}", x = network.sth)
network str(env.var)
node array(network.sth, env.var, node.NAME)
``````
#par()[Results:]
``````output
"this is true"
"12"
{
  b = [true, 12, "b"],
  a = [true, 12, "a"]
}
``````
#par()[Similary, env and network functions can be called anywhere. These functions cannot be mutable functions (change network internally).]
#par()[Taking the previous example, if we use env function #raw("count"), we get an error as the function arguments are different.]
``````task
network load_str("a->b")
node network.count()
network sum(array(env.count(), 1))
``````
#par()[\*Error\*:]
``````error
{
  b = 2,
  a = 2
}
Error in function count: Argument 1 (vars [& [bool]]) is required
``````
==== Node Variables/Functions
#par()[You can use #raw("node"), #raw("inputs"), #raw("output") and #raw("nodes") keywords to access node variables and functions from different contexts. #raw("nodes") is valid in all tasks, while the other 3 are only valid in a node task and refer to the current node, input nodes and output node respectively.]
``````task
network load_file("./data/mississippi.net")
env count(nodes._)
node inputs.NAME
``````
#par()[Results:]
``````output
7
{
  lower-mississippi = ["ohio", "upper-mississippi", "missouri", "arkansas", "red"],
  upper-mississippi = [],
  missouri = [],
  arkansas = [],
  red = [],
  ohio = ["tenessee"],
  tenessee = []
}
``````
#par()[You can call node functions not just for the node in the context, but also for input nodes, and output node:]
#par()[Please note that the root node (outlet) of the network doesn't have output node, so we need to skip that, which can be done through the #raw("output._?") which is checking for the dummy variable #raw("_") in #raw("output"), which is true if the node has an output.]
``````task
network load_file("./data/mississippi.net")
node[tenessee -> "lower-mississippi"] inputs.render("{_NAME}")
node[tenessee -> "lower-mississippi"](output._?) output.render("{_NAME}")
``````
#par()[Results:]
``````output
{
  tenessee = [],
  ohio = ["tenessee"],
  lower-mississippi = ["ohio", "upper-mississippi", "missouri", "arkansas", "red"]
}
{
  tenessee = "ohio",
  ohio = "lower-mississippi"
}
``````
#par()[You can also use #raw("nodes") keyword to call the function on each node, it can be used anywhere, but is useful for env and network tasks.]
``````task
network load_file("./data/mississippi.net")

env nodes.render("Node [{INDEX}] {_NAME}")
``````
#par()[Results:]
``````output
["Node [0] lower-mississippi", "Node [1] upper-mississippi", "Node [2] missouri", "Node [3] arkansas", "Node [4] red", "Node [5] ohio", "Node [6] tenessee"]
``````

== Plugins <intro-plugins>

== Further Reading
#par()[If you need help on any functions. Use the #raw("help") as a #raw("task"). You can use #raw("help node") or #raw("help network") for specific help. You can also browse through the function help window in the #raw("nadi-ide") for help related to each functions.]
``````task
help node render
``````
#par()[Results:]
``````output
node render (template: '& Template', safe: 'bool' = false)
Render the template based on the node attributes
# Arguments
- `template: & Template` String template to render
- `safe: bool` [def = false] if render fails keep it as it is instead of exiting


For more details on the template system. Refer to the String
Template section of the NADI book.
``````
#par()[Or you can use #raw("nadi --fnhelp <function>") using the #raw("nadi-cli").]
#par()[Now that you have the overview of the nadi system's data structures. We'll jump into the software structure and how to setup and use the system.]
#par()[If you want more details on any of the data structures refer the Developer's references, or the library documentation.]
#pagebreak(weak: true)
#pagebreak(weak: true)
#pagebreak(weak: true)
= Learn by Examples <learn-examples>
#table(columns: 2, table.header(
[Topic], [Learn About]
),
[#link(<learn-examples-attributes>)[Attributes]], [Setting and Getting Attributes],
[#link(<learn-examples-control>)[Control Flow]], [Control flow, if, else, while loops etc],
[#link(<learn-examples-connections>)[Connections]], [Loading and modifying connections],
[#link(<learn-examples-counting>)[Counting]], [Counting nodes in network, conditional],
[#link(<learn-examples-cumulative>)[Cumulative]], [Calculating Network cumulative sums and those],
[#link(<learn-examples-import-export>)[Import Export]], [Importing and exporting multiple data formats],
[#link(<learn-examples-str-templates>)[String Template]], [Using String Templates to do various things],
)
== Attributes <learn-examples-attributes>
#par()[There are 3 kind of attributes in nadi. Environment, Network and Node attributes. as their name suggests environment attributes are general attributes available in the current context. Network attributes are associated with the currenly loaded network. and node attributes are associated with each nodes.]
#par()[nadi has special syntax where you can get/set attributes for multiple nodes at once.]
``````task
network load_str("a -> b\n b -> d\n c -> d\n");
# environmental attribute
env.someattr = 123;
env.other = 1998-12-21;
env array(someattr, other)
# network attribute
network.someattr = true;
network.someattr
# node attributes
node.someattr = "string val";

node.someattr
``````
#par()[Results:]
``````output
[123, 1998-12-21]
true
{
  d = "string val",
  c = "string val",
  b = "string val",
  a = "string val"
}
``````
#par()[like you saw with the array function, variables used are inferred as the attributes of the current env/network/node task.]
#par()[you can use attributes from outside of current task type in some cases like:]
- env/network variables can be used anywhere
- node variables are valid in node tasks
- node tasks has special variables types like #raw("inputs") and #raw("output")
``````task
network load_str("a -> b\n b -> d\n c -> d\n");
# environmental attribute
env.someattr = 123;
env.other = 1998-12-21;
# network attribute
network.someattr = true;

# using network attr in env task
env array(network.someattr, other)

# using nodes in network task
network nodes.NAME
``````
#par()[Results:]
``````output
[true, 1998-12-21]
["d", "c", "b", "a"]
``````
#par()[Similarly inputs:]
``````task
network load_str("a -> b\n b -> d\n c -> d\n");

node inputs.NAME
``````
#par()[Results:]
``````output
{
  d = ["b", "c"],
  c = [],
  b = ["a"],
  a = []
}
``````
#par()[Refer to the network diagram below to verify the output are correct:]
``````task
network load_str("a -> b\n b -> d\n c -> d\n");
network svg_save("./output/attrs-simp.svg")
``````
#par()[Results:]
#align(center, image("./src/output/attrs-simp.svg"))

== Control Flow <learn-examples-control>
#par()[Task has some basic control flow required to write programs. They are if-else branches and while loops.]
==== Conditional (If-Else) Blocks
#par()[There are two kind of if-else branches. One is on an expression level. which means there has to be if and else branch both as it expects a return value. The following example shows the expression with if-else block.]
``````task
env.newvar = if (12 > 90) {"yes"} else {"no"};
env.newvar
``````
#par()[Results:]
``````output
"no"
``````
#par()[Trying to do it without else block will result in an parse error as the program will error with a syntax error, for example the code below is invalid]
``````task
env.newvar = if (12 > 90) {"yes"};
env.newvar
``````
#par()[That's when you can use the if-else block on the task level. This can be only if block as the execution blocks are tasks instead of expressions.]
#par()[Here, since the condition is negative the task inside the block is never executed, hence #raw("env.newvar") is empty.]
``````task
if (12 > 90) {
	env.newvar = "yes";
}
env.newvar
``````
#par()[\*Error\*:]
``````error
EvalError: Attribute not found
``````
==== While Loop
#par()[While loop runs the tasks inside the block repeatedly while the condition is satisfied. There is an iteration limit of 1,000,000 for now just in case people write infinite loop. This is arbritary.]
``````task
env.somevar = 1;
while (somevar < 10) {
	env.somevar
	env.somevar = env.somevar + 1;
}
``````
#par()[Results:]
``````output
1
2
3
4
5
6
7
8
9
``````
#par()[This can be used to repeat a set of tasks for a various reasons.]

== Connections <learn-examples-connections>
#par()[Connections between the nodes is the most important part of nadi. you can load networks by loading a file or string. The network is a simple multiline text with one edge (#raw("input -> output")) in each line. comments starting with #raw("#") are supported.]
==== Default is Empty Network
#par()[Tasks are run by default with an empty network. So you might still be able to work with network attributes, but the nodes will be empty. also note that when you load network it replaces the old one including the attributes.]
``````task
network.someattr = 1234;
network.someattr
``````
#par()[Results:]
``````output
1234
``````
#par()[But we can see the nodes are not there,]
``````task
network count()
network nodes.NAME
``````
#par()[Results:]
``````output
0
[]
``````
#par()[Trying to run node functions on the empty network means nothing is run]
``````task
node render("{NAME}")
``````
#par()[Results:]
``````output

``````
==== Loading Network from String
#par()[Here assume we have a network consisting of nodes of dams and gages like the following where dam nodes start with d and gages with g:]
``````task
network load_str("
d1 -> d2
d3 -> g2
d2 -> g1
g1 -> d4
g2 -> d4
d4 -> g3
");
network svg_save(
   "./output/simple-count.svg",
	label="[{INDEX}] {_NAME}"
)
``````
#par()[Results:]
#align(center, image("./src/output/simple-count.svg"))
==== Loading Network from a File
#par()[we can load a network from a file:]
``````task
network load_file("./data/mississippi.net");
network svg_save(
   "./output/ex-network-conn.svg",
	label="[{INDEX}] {_NAME}"
)
``````
#par()[Results:]
#align(center, image("./src/output/ex-network-conn.svg"))
==== Modifying the network
#par()[You can modify the network after loading it as well. The example below extracts just the nodes that are dams. Compare this with the previous network to see how the connections are retained during the subsets.]
``````task
network load_str("
d1 -> d2
d3 -> g2
d2 -> g1
g1 -> d4
g2 -> d4
d4 -> g3
");
node.is_dam = NAME match "^d[0-9]+";
network subset(nodes.is_dam);
network svg_save(
   "./output/simple-count-subset.svg",
	label="[{INDEX}] {_NAME}"
)
``````
#par()[Results:]
#align(center, image("./src/output/simple-count-subset.svg"))
#par()[This can be useful when you want to remove nodes that do not satisfy some selection criteria for your analysis without having to redo the network detection part.]

== Counting Nodes <learn-examples-counting>
#par()[Here assume we have a network consisting of nodes of dams and gages like the following where dam nodes start with d and gages with g:]
``````task
network load_str("
d1 -> d2
d3 -> g2
d2 -> g1
g1 -> d4
g2 -> d4
d4 -> g3
");
network svg_save(
   "./output/simple-count.svg",
	label="[{INDEX}] {_NAME}"
)
``````
#par()[Results:]
#align(center, image("./src/output/simple-count.svg"))
#par()[Simply counting number of nodes, or certain types of nodes in a network is done through #raw("count") function.]
``````task
network load_str("
d1 -> d2
d3 -> g2
d2 -> g1
g1 -> d4
g2 -> d4
d4 -> g3
");
node.g_node = NAME match "^g[0-9]+";
network count()
network count(nodes.g_node)
network count(nodes.g_node) / count()
``````
#par()[Results:]
``````output
7
3
0.42857142857142855
``````
#par()[when you call a network function, you get one output, while a node function will give you the output for each node like here:]
``````task
network load_str("
d1 -> d2
d3 -> g2
d2 -> g1
g1 -> d4
g2 -> d4
d4 -> g3
");
node.g_node = NAME match "^g[0-9]+";
node.g_node
``````
#par()[Results:]
``````output
{
  g3 = true,
  d4 = false,
  g2 = true,
  d3 = false,
  g1 = true,
  d2 = false,
  d1 = false
}
``````
#par()[Always be careful that node function is run for all the nodes separately, if you are running them without any variables from the node, then you can use network function, or environment function to get the results.]
#par()[Counting the number of nodes upstream of each node gives us the order of the nodes.]
``````task
network load_str("
d1 -> d2
d3 -> g2
d2 -> g1
g1 -> d4
g2 -> d4
d4 -> g3
");
node<inputsfirst>.nodes_us = 1 + sum(inputs.nodes_us);
network svg_save(
   "./output/simple-count-1.svg",
	label="{_NAME} = {nodes_us}"
)
``````
#par()[Results:]
#align(center, image("./src/output/simple-count-1.svg"))
#par()[We can add a condition and count the nodes that satisfy that condition only. Like counting the number of dams upstream of each node (including the node).]
``````task
network load_str("
d1 -> d2
d3 -> g2
d2 -> g1
g1 -> d4
g2 -> d4
d4 -> g3
");
node.is_dam = NAME match "^d[0-9]+";
node<inputsfirst>.dams_us = int(is_dam) + sum(inputs.dams_us);
network svg_save(
   "./output/simple-count-2.svg",
	label="{_NAME} = {dams_us}"
)
``````
#par()[Results:]
#align(center, image("./src/output/simple-count-2.svg"))
#par()[You can similarly count the number of gages downstream. Here we need a conditional unlike in previous cases as not all nodes have output. In case of inputs, a leaf node would have no inputs but #raw("sum([])") would still be a valid output of #raw("0"). But for node without output nodes, the variable type #raw("output") fails with #raw("NoOutputNode") error, so we add a conditional check to avoid that.]
``````task
network load_str("
d1 -> d2
d3 -> g2
d2 -> g1
g1 -> d4
g2 -> d4
d4 -> g3
");
node.is_gage = NAME match "^g[0-9]+";
node<outputfirst>.gages_ds = int(is_gage) + if (output._?) {
	output.gages_ds
	} else {
	0
};
network svg_save(
   "./output/simple-count-3.svg",
	label="{_NAME} = {gages_ds}"
)
``````
#par()[Results:]
#align(center, image("./src/output/simple-count-3.svg"))
#par()[Here the condition #raw("(output._?)") checks if there is output on the node or not by checking for the dummy variable #raw("_") which is present in all nodes/network.]

== Cumulative Sum <learn-examples-cumulative>
#par()[Here we can use the stream ordering formula to calculate the stream order for each node:]
``````task
network load_str("
d1 -> d2
d3 -> g1
d2 -> g1
g1 -> d4
g2 -> d4
d4 -> g3
");
node<inputsfirst>.stream_ord = max(inputs.stream_ord, 1) + int(count(inputs._?) > 1);
network svg_save(
   "./output/cumulative-1.svg",
	label="{_NAME} = {stream_ord}"
)
``````
#par()[Results:]
#align(center, image("./src/output/cumulative-1.svg"))
#par()[The first part takes the maximum order of the input nodes, then the second part #raw("int(count(inputs._?) > 1)") checks if there are more than one input, adding one to the order when multiple streams combine into one. You can use the funciton #raw("inputs_count()") instead of #raw("count(inputs._?)") to do the same thing.]
#par()[That is the core of the NADI Task System, you can write functions that have their own logic and then load them into the system. You can then use the syntax and network based analysis methods of NADI using those functions.]
#par()[And of course, we can visualize the different order of streams for easier understanding.]
``````task
network load_str("
d1 -> d2
d3 -> g1
d2 -> g1
g1 -> d4
g2 -> d4
d4 -> g3
");
node<inputsfirst>.stream_ord = max(inputs.stream_ord, 1) + int(count(inputs._?) > 1);
node.visual.linewidth = stream_ord / 2;
node(stream_ord == 1).visual.linecolor = "green";
node(stream_ord == 2).visual.linecolor = "blue";
node(stream_ord == 3).visual.linecolor = "red";
network svg_save(
   "./output/cumulative-2.svg",
	label="{_NAME} = {stream_ord}"
)
``````
#par()[Results:]
#align(center, image("./src/output/cumulative-2.svg"))

== Import Export Files <learn-examples-import-export>
#par()[Similar to how you can load network files, you can load attributes from files as well. Direct load of TOML format is supported from the internal plugins, while you might need external plugins for other formats.]
#par()[#raw("load_attrs") function takes a template, and reads a different files for each node to load the attributes from.]
``````task
network load_file("data/ohio.network")
node attributes.load_attrs("data/attrs/{_NAME}.toml")
network svg_save(
  "output/ohio-import-export.svg",
  label="{_NAME} (A = {basin_area?:f(2)})",
  height=700,
  bgcolor="gray"
)
``````
#par()[Results:]
#align(center, image("./src/output/ohio-import-export.svg"))
#par()[You can use the render function to see if the files being loaded are correct. Here we can see the examples for the first 4 nodes:]
``````task
network load_file("data/ohio.network")
node(INDEX<4) render("data/attrs/{_NAME}.toml")
``````
#par()[Results:]
``````output
{
  smithland = "data/attrs/smithland.toml",
  golconda = "data/attrs/golconda.toml",
  old-shawneetown = "data/attrs/old-shawneetown.toml",
  mountcarmel = "data/attrs/mountcarmel.toml"
}
``````
#par()[You can also read a attributes from string, so you can combine that with #raw("files.from_file") and load it.]
``````task
network load_file("data/ohio.network")
env.somevalue = attributes.parse_attrmap(
	files.from_file("data/attrs/smithland.toml")
);
env.somevalue.basin_area
env.somevalue.length
``````
#par()[Results:]
``````output
371802.16
1675.95
``````
#par()[You can export csv files]
``````task
network load_file("data/ohio.network")
node attributes.load_attrs("data/attrs/{_NAME}.toml")
network table.save_csv("output/ohio-export.csv", ["NAME", "basin_area", "length"])
network command("cat output/ohio-export.csv | head", echo=true)
``````
#par()[Results:]
``````output
$ cat output/ohio-export.csv | head
NAME,basin_area,length
"smithland",371802.16,1675.95
"golconda",370942.26,1701.32
"old-shawneetown",363656.85,1772.27
"mountcarmel",74359.92,1918.08
"jt-myers",277962.45,1791.07
"evansville",275482.9,1878.29
"calhoun",18540.88,1992.5
"newburgh",253065.62,1903.58
"cannelton",249382.5,1993.72
``````
==== GIS Files
#par()[First we make a GIS file by exporting. The image below shows the resulting points (red) from the shapefile and connections (black) from the Geopackage file when we visualize this on QGIS (with background of Terrain and Ohio River tributaries).]
``````task
network load_file("data/ohio.network")
node attributes.load_attrs("data/attrs/{_NAME}.toml")
node.geometry = render("POINT ({lon} {lat})");
network gis.gis_save_nodes(
  "output/ohio-nodes.shp",
  "geometry",
  {
    NAME = "String",
	basin_area = "Float",
	length = "Float"
  }
)
# Exporting the edges
network gis.gis_save_connections(
  "output/ohio-connections.gpkg",
  "geometry"
)
``````
#par()[Results:]
#par()[]
#par()[The geometry attributes should be #link("https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry")[WKT String].]
#par()[Now we are using the generated GIS files to load the network and the attributes:]
``````task
network gis.gis_load_network("output/ohio-connections.gpkg", "start", "end")
network gis.gis_load_attrs("output/ohio-nodes.shp", "NAME")

network svg_save(
  "output/ohio-from-gis.svg",
  label="{_NAME} (A = {basin_area?:f(2)}; L = {length:f(1)})",
  height=700,
  bgcolor="gray"
)
``````
#par()[Results:]
#align(center, image("./src/output/ohio-from-gis.svg"))
#par()[As we can see the plugins make it easier to interoperate with a lot of different data formats. Here GIS plugin will support any file types supported by #raw("gdal"). Similarly, other formats can be supported by writing plugins.]

== String Templates <learn-examples-str-templates>
#pagebreak(weak: true)
#pagebreak(weak: true)
#pagebreak(weak: true)
= Nadi Extension Capabilities <system-extensions>
#par()[Nadi System can be extended for custom use cases with the following ways:]
- #link("../devref/string-templates.md#advanced-string-template-with-lisp")[LISP on String Template]
- Task System
- Rust Library
- Python Library
- Plugin System
#pagebreak(weak: true)
= List of All Functions
#par()[All the functions available on this instance of nadi, are listed here.]
=== Env Functions

=== Node Functions

=== Network Functions

#pagebreak(weak: true)
#pagebreak(weak: true)

= Python Library        
== Nadi Py
#par()[This can be installed from #raw("pypi") with #raw("pip install nadi-py") command.]
#par()[Then you can simply import and use it:]
``````python
import nadi

net = nadi.Network.from_str("a -> b")
print([n.NAME for n in net.nodes])
``````
#par()[The functions are available inside the #raw("nadi.functions") submodule.]
``````python
import nadi
import nadi.functions as fn

net = nadi.Network.from_str("a -> b")
fn.network.svg_save(net, "test.svg")
``````
=== Combining the power of python and Task System
#par()[You can combine the power of python with task system using the #raw("command") function from Nadi. Basically, you write your logic that cannot be written in nadi in python, you can use #raw("nadi-py") if you need to parse network files, load attributes or call any other nadi functions. And you can pass the results of the python script at the end by simply printing it to the standard output.]
#par()[Future work is under consideration to have a tight couple between the python and nadi system.]

== Differences with Task System
#par()[The difference from Task system is that now we use python syntax and the python functions. The environment from task system is no longer available, and the node functions are not automatically run in a loop.]
#par()[We lose the advantages brought by the Domain Specific Programming Language, while gaining the flexibility and the well developed libraries of the python language.]
#par()[Some examples showing how you'd have to write python codes from equivalent examples in the book are shown below.]
==== Example 1: looping through the nodes
``````task
network load_str("a -> b\nc -> b")
node(output._?) echo(env.render("{i} -> {o}", i=node.INDEX, o=output.INDEX))
``````
#par()[Results:]
``````output
1 -> 0
2 -> 0
``````
#par()[Equivalent Python:]
``````python
import nadi

net = nadi.Network.from_str("a -> b\nc -> b")
for node in net.nodes:
    out = node.output()
	if out is None:
	    continue
    print(f"{node.INDEX} -> {out.INDEX}")
``````
#par()[Here the code for python is longer because it is general purpose and doesn't have the syntax tailored for network analysis like with Nadi Task System.]
==== Example 2: Skip execution when variable is absent
#par()[If we had to check for an attribute, then it becomes even more complicated.]
``````task
node(somevar?) somefunc(somevar)
``````
``````python
import nadi
import nadi.functions as fn

net = nadi.Network.from_str("a -> b\nc -> b")
for node in net.nodes():
	try:
	    fn.node.somefun(node, node.somevar)
	except AttributeError:
	    continue
``````
#par()[In case of multiple variables being used, the #raw("AttributeError") might catch all of them, further fine tuning in python could make the code far longer than in nadi.]

== Plugins
#par()[Not only can you use #raw("nadi-py") to write network based algorithms in python, you can also use it to write executable plugins that you can use to run analysis in python and feed it back to nadi system.]
#par()[First thing to say about that is, you don't need #raw("nadi-py") for writing python plugins, as they are run as a normal python scripts.]
==== Example without using nadi-py
#par()[Here is an example task that calls python using the #raw("command") function:]
``````task
network load_file("scioto.network")

# load average streamflow from the csv file
# containing timeseries using python
node command("python area-and-streamflow.py {_NAME}")

# this just prints the attributes in csv format.
network print_attr_csv("INDEX", "area", "streamflow")
``````
#par()[Here the #raw("command") function takes a string template, renders it and runs it as a shell command for each node.]
#par()[Our python script should have a way to read that node's name that we passed to the python command.]
``````python
import sys
import pandas as pd

try:
    station = sys.argv[1]
except IndexError:
    print("Give station")
    exit(1)

df = pd.read_csv(f"data/streamflow/{station}.csv", header=None)
sf = df.iloc[:, 4]
sf.index = pd.to_datetime(df.iloc[:, 2])
daily = sf.resample('1d').mean()
counts = daily.groupby(daily.index.year).count()
counts.index.name = "datetime"
daily.index.name = "datetime"
annual = daily.groupby(daily.index.year).mean().loc[counts > 300]

print("nadi:var:sf_mean=", float(daily.mean()))

for year, flow in annual.items():
    print(f"nadi:var:sf_year_{year}={flow}")
``````
#par()[Here the line #raw("sys.argv[1]") reads the argument from command line (node's name in this case). And reads the data for that node. The ouput is printed with prefix #raw("nadi:var:") which tells nadi to load as #raw("key=val") pair for that node.]
==== Example using nadi-py
#par()[The same example can be written using #raw("nadi-py") so that the execution is very short (as it is being run as a network function instead of node function; #raw("command") is a slow function as a new shell instance has to be created every time it is invoked).]
#par()[Here we use the #raw("command") network function and pass the network file as input. If your network has changed you can use #raw("save_file") #raw("network") function to save the network as a text file and then pass that instead.]
``````task
network load_file("scioto.network")

# load average streamflow from the csv file
# containing timeseries using python
network command("python area-and-streamflow.py scioto.network")

# this just prints the attributes in csv format.
network print_attr_csv("INDEX", "area", "streamflow")
``````
#par()[The corresponding python script now will look like this:]
``````python
import sys
import pandas as pd
import nadi

try:
    network = sys.argv[1]
except IndexError:
    print("Give station")
    exit(1)

for node in nadi.Network(network).nodes():
	station = node.NAME
	df = pd.read_csv(f"data/streamflow/{station}.csv", header=None)
	sf = df.iloc[:, 4]
	sf.index = pd.to_datetime(df.iloc[:, 2])
	daily = sf.resample('1d').mean()
	counts = daily.groupby(daily.index.year).count()
	counts.index.name = "datetime"
	daily.index.name = "datetime"
	annual = daily.groupby(daily.index.year).mean().loc[counts > 300]

	print(f"nadi:var:{station}:sf_mean=", float(daily.mean()))

	for year, flow in annual.items():
		print(f"nadi:var:{station}:sf_year_{year}={flow}")
``````
#par()[Here we load the network using #raw("nadi-py"), and then loop through the node, and pass the variables back to nadi through stdout. We have to pass the node names with the #raw("nadi:var:") as this is being run for the whole network. Without the node name, it'll take the #raw("key=val") pair as network attribute.]
#par()[This should allow users to have a lot of flexibility in using python to do complex analysis and get the results back into nadi directly. You can also save the results of the python script into a file, and check if the file exists before running the command from nadi to save the redundant computations.]

== Examples
#par()[TODO: add examples from papers' case studies.]
#pagebreak(weak: true)
#pagebreak(weak: true)

= Plugin Developer Guide  
== Executable Plugins <plugin-dev-exe-plugins>
#par()[Executable plugins are programs that can be called from terminal. The #link(<plugins-command-node.command>)[node #raw("command") function], #link(<plugins-command-network.command>)[network #raw("command") function] and their families in the #link(<plugins-command>)[#raw("command") plugin] have the capacity to run external programs through the command line.]
#par()[The inputs to the program is given through the command line arguments, while the output of the programs are read through the standard output of the program. This can be used to call different/same commands for nodes with arguments dependent on their attributes.]
#par()[And the output from the programs are taken by reading their stdout (standard output). Any lines starting from #raw("nadi:var:") (prefix) is considered a communication attempt with Nadi. Currently, you can set attribute values by providing #raw("key=val") pairs after the prefix. The node function will set it for current node, and network function will set it for the network. Furthermore, in network function, you can add one more section after prefix to set node attributes. For example, #raw("nadi:var:node1:value=12") will set the #raw("value") attribute to #raw("12") in the node named #raw("node1") in the current network.]
#par()[The executable plugin or commands are language agnostic, as long as the command is available to run from the parent shell they will be run.]
#par()[To learn how to write code in your language to parse command line arguments refer to the #link("https://en.wikipedia.org/wiki/Command-line_argument_parsing")[Wikipedia page on Command Line Arguments]]
#par()[The following section shows example programs written in python and R that can interact with nadi in this way.]
==== Python
#par()[Here is an example python script that can be called from nadi for each node. This script just reads a CSV file and passes the attributes to nadi, but more complicated programs can be written by the users.]
#par()[First part is importing libraries and getting the arguments from nadi. The code below reads one string as a commandline argument and saves that into #raw("station") variable.]
``````python
import sys
import pandas as pd

try:
    station = sys.argv[1]
except IndexError:
    print("Give station")
    exit(1)
``````
#par()[Then we can use any python logic with any libraries to do what we want. Here it reads the CSV and extracts values based on the station name. This is just an example, but you can load different csv files for each station and do a lot of analysis before sending those variables to nadi.]
``````python
df = pd.read_csv(f"data/streamflow/{station}.csv", header=None)
sf = df.iloc[:, 4]
sf.index = pd.to_datetime(df.iloc[:, 2])
sf = sf.resample('1d').mean()
``````
#par()[Once we have our variables from analysis, we can simply print them with #raw("nadi:var:") prefix so that nadi knows they are the variables it should read and load into each node.]
``````python
print("nadi:var:sf_mean=", float(sf.mean()))

for year, flow in sf.groupby(sf.index.year).mean().items():
    print(f"nadi:var:sf_year_{year}={flow}")
``````
#par()[Now we can call this script from inside the nadi tasks system like the following, assuming the python file is saved as #raw("streamflow.py").]
``````task
node command("python streamflow.py {_NAME}")
``````
#par()[If you want to know what the template will be rendered as, use #raw("render") function, and if you want to check whether it exists or not, you can use #raw("exists") function.]
==== RScript
#par()[Similar to most programming languages R can also read command line arguments when ran with #raw("RScript") command instead of #raw("R").]
#par()[For example if you run the following script in a file called #raw("test.r") and ran it with command #raw("Rscript test.r some args 2"), you get the output of #raw("[1] \"some\" \"args\" \"2\"")]
``````r
args <- commandArgs(trailingOnly = TRUE)
print(args)
``````
#par()[So you can use the same method like in python to pass arguments, do analysis and pass it back using the #raw("cat") function in r as shown below. #raw("cat") function avoids printing the #raw("[1]") type indices to the stdout.]
``````r
cat(sprintf("nadi:var:this_val=%d\n", 1200))
``````

== Compiled Plugins
#par()[As it is not possible to forsee all the use cases in advance, the nadi software can be easily extended (easy being an relative term) to account for different use cases.]
#par()[The program can load compiled shared libraries (#raw(".dll") in windows, #raw(".so") in linux, and #raw(".dylib") on mac). Since they are shared libraries compiled into binaries, any programming languages can be used to generate those. So far, the #raw("nadi_core") library is available for #raw("Rust") only. Using that, plugins can be written and those functions can be made available from the system.]
#par()[Nadi core automatically loads:]
- internal plugins if feature #raw("functions") is used in #raw("nadi_core") to compile it,
- external plugins in the directories inside the #raw("NADI_PLUGIN_DIRS") environmental variables. The plugins must be compiled using the same #raw("nadi_core") version and must have the same internal ABI for data types.
#par()[The syntax for functions in plugins are same for internal and external plugins. While the way to register the plugin differ slightly.]
#par()[The difference between the internal and external plugins are that, internal plugins are compiled with the #raw("nadi_core") and come with the program, while external plugins are separately compiled and loaded through dynamic libraries.]
#par()[The methods for writing the plugins are the same, except at the top level: to export plugins, you have to use [#raw("nadi_core::nadi_plugin::nadi_plugin")] macro for external plugins while [#raw("nadi_core::nadi_plugin::nadi_internal_plugin")] for internal ones.]
#par()[In the next sections we will go in detail about how to write plugins and load them in nadi.]
=== Internal Plugins
#par()[Internal plugins come with the nadi system. They are only modified between the different versions of Nadi.]
#par()[The internal plugins provide core functionality of the Task system like data conversion, parsing network/attribute files, logical operations, template rendering, etc.]
#par()[Future planned internal plugin functions can be found in #link("https://github.com/Nadi-System/nadi-futures")[nadi-futures] repository. Which in itself is an external plugin.]

=== External Plugins
#par()[External plugins are plugins that are their own separate programs that compile to a shared library. The shared library has information about the name of the plugin, the functions that are available, as well as the bytecode required to run the functions.]
#par()[You have to use the #raw("nadi_core") library and the macros available there to make the plugins. Although it might be possible to write it without the macros (an example is provided), it is strongly discouraged. The example only serves as a way to demonstrate the inner working of the external plugins.]
#par()[Some examples of external plugins are given in the #link("https://github.com/Nadi-System/nadi-plugins-rust")[#raw("nadi-plugins-rust") repository].]
#par()[An example of a complex external plugin can be found in the #raw("gis") plugin from #link("https://github.com/Nadi-System/nadi-gis")[#raw("nadi-gis") repository].]
===== Steps to create a Plugin
#par()[#raw("nadi") CLI tool has a function that can generate a plugin template. Simply run the #raw("nadi") command with #raw("--new-plugin") flag.]
``````
nadi --new-plugin <plugin-name>
``````
#par()[This will create a directory with plugin's name with #raw("Cargo.toml") and #raw("src/lib.rs") with some sample codes for plugin functions. You can then edit them as per your need.]
#par()[The generated files using #raw("nadi --new-plugin sample") look something like this:]
#par()[Cargo.toml:]
``````toml
[package]
name = "sample"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

# make sure you use the same version of nadi_core, your nadi-system is in
[dependencies]
abi_stable = "0.11.3"
nadi_core = "0.7.0"
``````
#par()[src/lib.rs:]
``````rust
use nadi_core::nadi_plugin::nadi_plugin;

#[nadi_plugin]
mod sample {
    use nadi_core::prelude::*;

    /// The macros imported from nadi_plugin read the rust function you
    /// write and use that as a base to write more core internally that
    /// will be compiled into the shared libraries. This means it'll
    /// automatically get the argument types, documentation, mutability,
    /// etc. For more details on what they can do, refer to nadi book.
    use nadi_core::nadi_plugin::{env_func, network_func, node_func};

    /// Example Environment function for the plugin
    ///
    /// You can use markdown format to write detailed documentation for the
    /// function you write. This will be availble from nadi-help.
    #[env_func(pre = "Message: ")]
    fn echo(message: String, pre: String) -> String {
        format!("{}{}", pre, message)
    }

    /// Example Node function for the plugin
    #[node_func]
    fn node_name(node: &NodeInner) -> String {
        node.name().to_string()
    }

    /// Example Network function for the plugin
    ///
    /// You can also write docstrings for the arguments, this syntax is not
    /// a valid rust syntax, but our macro will read those docstrings, saves
    /// it and then removes it so that rust does not get confused. This means
    /// You do not have to write separate documentation for functions.
    #[network_func]
    fn node_first_with_attr(
        net: &Network,
        /// Name of the attribute to search
        attrname: String,
    ) -> Option<String> {
        for node in net.nodes() {
            let node = node.lock();
            if node.attr_dot(&attrname).is_ok() {
                return Some(node.name().to_string());
            }
        }
        None
    }
}
``````
#par()[The plugin can be compiled with the #raw("cargo build") or #raw("cargo build --release") command, it'll generate the shared library in the #raw("target/debug") or #raw("target/release") folder. You can simply copy it to directory in #raw("NADI_PLUGIN_DIRS") for it to be loaded.]
=== Functions
#par()[Plugin functions are very close to normal rust functions, with extra syntax for the function arguments, and limited function argument and return types.]
===== Function Types
#par()[There are 3 function types:]
- environment
- node
- network
#par()[the macro used for each function type are availabel from #raw("nadi_core::nadi_plugin"). All the macro take optional list of #raw("key = value") pairs that can act like default arguments to the functions while called from the task system.]
#par()[These macro will read the rust function and generate the necessary plugin code, function signature, documentation, and will even save the original code so that users can browse it through the #raw("nadi-help").]
===== Function Arguments
#par()[There are 5 types of function arugments, that are denoted by the following attributes]
#table(columns: 3, table.header(
[macro attr], [Type], [Supported Types]
),
[], [Node/Network], [#raw("&")/#raw("& mut") + #raw("NodeInner")/#raw("Network")],
[], [Normal arguments], [#raw("T: FromAttribute")],
[\#[relaxed]], [Relaxed arguments], [#raw("T: FromAttributeRelaxed")],
[\#[args]], [Positional Arguments List], [#raw("&[Attribute]")],
[\#[kwargs]], [Keyword Arguments AttrMap], [#raw("&AttrMap")],
)
#par()[Users can not provide the argument #raw("Node")/#raw("Network") for node/network function as it is automatically provided based on the context.]
#par()[Furthermore, there are required and optional arguments. And users can optionally omit the arguments that are of type #raw("Option<T>"), or have default value in the macro (e.g. #raw("safe = false") in the codes below).]
#par()[For now, the function arguments except the #raw("Node") or #raw("Network") cannot be #raw("mut"). But they can be reference of #raw("T") if #raw("T") satisfies the trait constraints, for example, instead of #raw("Vec<String>"), it can be #raw("&[String]"). But because the function context is evaluated for each node/network, there is no optimization by using the references.]
===== Return Types
#par()[Function Return can be empty, an attribute value, or an error. When a function returns an error, the execution is halted. When it doesn't return a value and an assignment is performed, it will error as well.]
#par()[The return type of the function should implement #raw("Into<FunctinRet>"), refer to the documentation for #link("https://docs.rs/nadi_core/latest/nadi_core/functions/enum.FunctionRet.html")[#raw("nadi_core::functions::FunctionRet")] to see what types implement it. You can also implement that for your own types.]
#par()[You can simply use any type that satisfy the trait requirement mentioned above as a function return and the nadi macros will convert them automatically for you.]
===== Verbosity
#par()[In future versions the functions will also get a flag that will let them know how verbose the functions can be. This will also come with a way to pass progress and other information while the function is still running.]
===== Examples
#par()[Refer to the nadi \_core, and other plugin repositories for sample codes for plugin functions as they are always up to date with the current version.]
#par()[Here is an example containing render function that is available on all function types.]
``````rust
    /// Render the template based on the given attributes
    ///
    /// For more details on the template system. Refer to the String
    /// Template section of the NADI book.
    #[env_func(safe = false)]
    fn render(
        /// String template to render
        template: &Template,
        #[kwargs] keyval: &AttrMap,
        /// if render fails keep it as it is instead of exiting
        safe: bool,
    ) -> Result<String, String> {
        let text = if safe {
            keyval
                .render(template)
                .unwrap_or_else(|_| template.original().to_string())
        } else {
            keyval.render(template).map_err(|e| e.to_string())?
        };
        Ok(text)
    }
``````
``````rust
    /// Render the template based on the node attributes
    ///
    /// For more details on the template system. Refer to the String
    /// Template section of the NADI book.
    #[node_func(safe = false)]
    fn render(
        node: &NodeInner,
        /// String template to render
        template: &Template,
        /// if render fails keep it as it is instead of exiting
        safe: bool,
    ) -> Result<String, String> {
        let text = if safe {
            node.render(template)
                .unwrap_or_else(|_| template.original().to_string())
        } else {
            node.render(template).map_err(|e| e.to_string())?
        };
        Ok(text)
    }
``````
``````rust
    /// Render from network attributes
    #[network_func(safe = false)]
    fn render(
        network: &Network,
        /// Path to the template file
        template: &Template,
        /// if render fails keep it as it is instead of exiting
        safe: bool,
    ) -> Result<String, String> {
        let text = if safe {
            network
                .render(template)
                .unwrap_or_else(|_| template.original().to_string())
        } else {
            network.render(template).map_err(|e| e.to_string())?
        };
        Ok(text)
    }
``````
=== Environment Functions
#par()[Environment functions are like any normal function on programming languages that take arguments and run code. In Nadi environment functions can be called from any scope. For example, if a node function and environement function share the same name, then in a node task node function is called, but in network task env function is called.]
#par()[Environment functions are denoted in the plugins with #raw("#[env_func]") macro. All the arguments this function takes need to be provided by user or through default values.]
#par()[Here is an example of a environment function #raw("and") in plugin #raw("logic").]
``````rust
    /// Boolean and
    #[env_func]
    fn and(
        /// List of attributes that can be cast to bool
        #[args]
        conds: &[Attribute],
    ) -> bool {
        let mut ans = true;
        for c in conds {
            ans = ans && bool::from_attr_relaxed(c).unwrap();
        }
        ans
    }
``````
#par()[This function can be called inside the task system in different context like follows:]
``````task
env and(true, 12)
env.something = false
env and(something, true) == (something & true)

network and(what?, and(true, true))
``````
#par()[Results:]
``````output
true
true
false
``````

=== Node Functions
#par()[Node functions are run for each node in the network (or a selected group of nodes). Hence, it takes the first argument as #raw("& NodeInner") or #raw("& mut NodeInner") depending on the purpose of the function. Immutable functions can be called from any place, while mutable functions can only be called once on the outermost layer on the task.]
#par()[Other arguments and the return types for node functions are the same as the environement functions.]

=== Network Functions
#par()[Network functions, like node functions take #raw("&Network") or #raw("& mut Network") as the first argument. It has the same restrictions as the env/node functions for the arguments and the return types.]
#pagebreak(weak: true)
#pagebreak(weak: true)
#pagebreak(weak: true)
#pagebreak(weak: true)
#pagebreak(weak: true)

= User Reference
== Example Usage
==== Ohio River Streamflow Routing Project
#par()[The Network for the flow routing is as follows:]
``````task
network load_file("./data/ohio.network")
network svg_save(label="{_NAME}", outfile = "./output/ohio.svg", height=1000)
``````
#par()[Results:]
#align(center, image("./src/output/ohio.svg"))
=== Making Tables
``````table
<Node ID => {_NAME}
<Title => {_description:case(title):repl(Ky,KY):repl(In,IN):repl(Wv,WV):repl(Oh,OH)?}
>Latitude => {lat:f(4)}
>Longitude => {lon:f(4)}
``````
#table(columns: 4, align: (left, left, right, right), table.header(
[Node ID], [Title], [Latitude], [Longitude]
),
[smithland], [OHio River at Smithland Dam Smithland KY], [37.1584], [-88.4262],
[golconda], [OHio River at Dam 51 at Golconda, Il], [37.3578], [-88.4825],
[old-shawneetown], [OHio River at Old Shawneetown, Il-KY], [37.6919], [-88.1333],
[mountcarmel], [Wabash River at Mt. Carmel, Il], [38.3983], [-87.7564],
[jt-myers], [OHio River at Uniontown Dam, KY], [37.7972], [-87.9983],
[evansville], [OHio River at Evansville, IN], [37.9723], [-87.5764],
[calhoun], [Green River at Lock 2 at Calhoun, KY], [37.5339], [-87.2639],
[newburgh], [Newburgh], [37.9309], [-87.3722],
[cannelton], [OHio River at Cannelton Dam at Cannelton, IN], [37.8995], [-86.7055],
[shepherdsville], [Salt River at Shepherdsville, KY], [37.9851], [-85.7175],
[mcalpine], [OHio River at Louisville, KY], [38.2803], [-85.7991],
[lockport], [Kentucky River at Lock 2 at Lockport, KY], [38.4390], [-84.9633],
[markland], [OHio River at Markland Dam Near Warsaw, KY], [38.7748], [-84.9644],
[milford], [Little Miami River at Milford OH], [39.1714], [-84.2980],
[catawba], [Licking River at Catawba, KY], [38.7103], [-84.3108],
[hamilton], [Great Miami River at Hamilton OH], [39.3912], [-84.5722],
[perintown], [East Fork Little Miami River at Perintown OH], [39.1370], [-84.2380],
[brookville], [Whitewater River at Brookville, IN], [39.4075], [-85.0129],
[meldahl], [Meldahl], [38.7972], [-84.1705],
[higby], [Scioto River at Higby OH], [39.2123], [-82.8638],
[greenup], [Greenup], [38.6468], [-82.8608],
[grayson], [Little Sandy River at Grayson, KY], [38.3301], [-82.9393],
[ashland], [OHio River at Ashland, KY], [38.4812], [-82.6365],
[branchland], [Guyandotte River at Branchland, WV], [38.2209], [-82.2026],
[rc-byrd], [Rc-Byrd], [38.6816], [-82.1883],
[charleston], [Kanawha River at Charleston, WV], [38.3715], [-81.7021],
[racine], [OHio River at Racine Dam, WV], [38.9167], [-81.9121],
[belleville], [OHio River at Belleville Dam, WV], [39.1190], [-81.7424],
[mcconnelsville], [Muskingum River at McConnelsville OH], [39.6451], [-81.8499],
[athens], [Hocking River at Athens OH], [39.3290], [-82.0876],
[elizabeth], [Little Kanawha River at Palestine, WV], [39.0590], [-81.3896],
[willow-island], [Willow-Island], [39.3605], [-81.3204],
[hannibal], [Hannibal], [39.6671], [-80.8653],
[pike-island], [OHio River at Martins Ferry, OH], [40.1051], [-80.7084],
[new-cumberland], [New-Cumberland], [40.5277], [-80.6276],
[montgomery], [Montgomery], [40.6486], [-80.3855],
[beaverfalls], [Beaver River at Beaver Falls, PA], [40.7634], [-80.3151],
[dashields], [OHio River at Sewickley, PA], [40.5492], [-80.2056],
[emsworth], [Emsworth], [40.5043], [-80.0889],
[natrona], [Allegheny River at Natrona, PA], [40.6153], [-79.7184],
[elizabeth2], [Monongahela River at Elizabeth, PA], [40.2623], [-79.9012],
[sutersville], [Youghiogheny River at Sutersville, PA], [40.2402], [-79.8067],
)
#par()[Nadi style table with network information:]
``````table
network load_file("./data/ohio.network")
!node load_attrs("./data/attrs/{_NAME}.toml")
network clip()
network echo("../output/ohio-table.svg")
# ^Ind => =(+ (st+num 'INDEX) 1)
<Node ID => {_NAME}
<Title => {_description:case(title):repl(Ky,KY):repl(In,IN):repl(Wv,WV):repl(Oh,OH)?}
>Latitude => {lat:f(4)}
>Longitude => {lon:f(4)}
``````
#par()[\*Error\*:]
``````error
network function: "table_to_svg" not found
``````

#par()[Old Result (needs graphics plugin):]
#align(center, image("./src/output/ohio-table.svg"))

=== Generating Reports
#par()[So we write this template:]
``````stp-md

## Ohio River Routing Project

<!-- ---8<---:[smithland]: -->
Our basin Outlet is at {_description:case(title):repl(Ky,KY)} with the total basin area {basin_area:f(1)} acre-ft.
<!-- ---8<--- -->

The lower part of the Ohio basin are specifically important to us. Those are:
| ID      | Basin Area   | Length to Outlet |
|---------|-------------:|-----------------:|
<!-- ---8<---:[greenup -> smithland]: -->
| {_NAME} | {basin_area:f(1)} | {length:f(2)}  |
<!-- ---8<--- -->


We used 4 locks and dams in the ohio river as representative locks and dams as below:

<!-- ---8<---:["willow-island",racine,markland,smithland]: -->
- {_NAME:repl(-, ):case(title)?}

  ![](../data/{_NAME}.svg)
<!-- ---8<--- -->
``````
#par()[Which makes the table only for the main-stem ohio:]
``````task
network load_file("./data/ohio.network")
!node load_attrs("./data/attrs/{_NAME}.toml")
network clip()
network render("./data/ohio-report.template")
``````
#par()[Results:#linebreak()
"./data/ohio-report.template"]

=== Analysing Timeseries
==== Looking at Data Gaps
#par()[Couting the gaps in a csv data with all the nodes is easy. Let's look at the top 5 nodes with data gaps.]
``````task
network load_file("./data/ohio.network")
network clip()
network csv_count_na(
	"./data/ts/observed.csv",
	sort=true,
	head = 5
)
``````
#par()[\*Error\*:]
``````error
----8<----

network function: "csv_count_na" not found
``````
#par()[Running it for two timeseries, and comparing them base don network information. We can see the downstream part have more missing data on natural timeseries.]
``````task
network load_file("./data/ohio.network")
network csv_count_na("./data/ts/observed.csv", outattr = "observed_missing")
network csv_count_na("./data/ts/natural.csv", outattr = "natural_missing")
network table_to_svg(
	template="
<Node=> {_NAME}
>Observed => {observed_missing}
>Natural => {natural_missing}
",
	outfile="./output/natural-gaps.svg"
)
``````
#par()[\*Error\*:]
``````error
network function: "csv_count_na" not found
``````
#par()[Old Result:]
#align(center, image("./src/output/natural-gaps.svg"))

=== Visualizing Data Gaps
#par()[To look at the temporal distribution of the gaps, we can use this function.]
``````task
network load_file("./data/ohio.network")
network csv_count_na("./data/ts/natural.csv", outattr = "nat_na")
network csv_data_blocks_svg(
	csvfile="./data/ts/natural.csv",
	outfile="./output/natural-blocks.svg",
	label="{_NAME} ({=(/ (st+num 'nat_na) 365.0):f(1)} yr)"
)
network clip()
network echo("../output/natural-blocks.svg")
``````
#par()[\*Error\*:]
``````error
network function: "csv_count_na" not found
``````
#par()[Old Result:]
#align(center, image("./src/output/natural-blocks.svg"))
``````task
network load_file("./data/ohio.network")
network csv_count_na("./data/ts/observed.csv", outattr = "obs_na")
network csv_data_blocks_svg(
	csvfile="./data/ts/observed.csv",
	outfile="./output/observed-blocks.svg",
	label="{_NAME} ({obs_na})"
)
network clip()
network echo("../output/observed-blocks.svg")
``````
#par()[\*Error\*:]
``````error
network function: "csv_count_na" not found
``````
#par()[Old Result:]
#align(center, image("./src/output/observed-blocks.svg"))

#pagebreak(weak: true)
#pagebreak(weak: true)
#pagebreak(weak: true)
#pagebreak(weak: true)
= Internal Plugins
#par()[There are some plugins that are provided with the #raw("nadi_core") library. They are part of the library, so users can directly use them.]
#par()[For example in the following tasks file, the functions that are highlighted are functions available from the core plugins. Other functions need to be loaded from plugins.]
``````task
# sample .tasks file which is like a script with functions
node<inputsfirst> print_attrs("uniqueID")
node show_node()
network save_graphviz("/tmp/test.gv")
node<inputsfirst>.cum_val = node.val + sum(inputs.cum_val);

node[WV04113,WV04112,WV04112] print_attr_toml("testattr2")
node render("{NAME} {uniqueID} {_Dam_Height_(Ft)?}")
node list_attr("; ")
# some functions can take variable number of inputs
network calc_attr_errors(
    "Dam_Height_(Ft)",
    "Hydraulic_Height_(Ft)",
    "rmse", "nse", "abserr"
)
node sum_safe("Latitude")
node<inputsfirst> render("Hi {SUM_ATTR}")
# multiple line for function arguments
network save_table(
	"test.table",
	"/tmp/test.tex",
	true,
	radius=0.2,
	start = 2012-19-20,
	end = 2012-19-23 12:04
	)
node.testattr = 2
node set_attrs_render(testattr2 = "{testattr:calc(+2)}")
node[WV04112] render("{testattr} {testattr2}")

# here we use a complicated template that can do basic logic handling
node set_attrs_render(
    testattr2 = "=(if (and (st+has 'Latitude) (> (st+num 'Latitude) 39)) 'true 'false)"
)
# same thing can be done if you need more flexibility in variable names
node load_toml_string(
    "testattr2 = =(if (and (st+has 'Latitude) (> (st+num 'Latitude) 39)) 'true 'false)"
)
# selecting a list of nodes to run a function
node[
	# comment here?
    WV04113,
    WV04112
] print_attr_toml("testattr2")
# selecting a path
node[WV04112 -> WV04113] render("=(> 2 3)")
``````
== Attributes
==== strmap { \#env.strmap }
``````sig
env attributes.strmap(
    attr: '& str',
    attrmap: '& AttrMap',
    default: 'Option < Attribute >'
)
``````
===== Arguments
- #raw("attr: '& str'") =\> Value to transform the attribute
- #raw("attrmap: '& AttrMap'") =\> Dictionary of key=value to map the data to
- #raw("default: 'Option < Attribute >'") =\> Default value if key not found in #raw("attrmap")
#par()[map values from the attribute based on the given table]
==== parse \_attr { \#env.parse \_attr }
``````sig
env attributes.parse_attr(toml: '& str')
``````
===== Arguments
- #raw("toml: '& str'") =\> String to parse into attribute
#par()[Set node attributes based on string templates]
==== parse \_attrmap { \#env.parse \_attrmap }
``````sig
env attributes.parse_attrmap(toml: 'String')
``````
===== Arguments
- #raw("toml: 'String'") =\> String to parse into attribute
#par()[Set node attributes based on string templates]
==== float \_transform { \#env.float \_transform }
``````sig
env attributes.float_transform(value: 'f64', transformation: '& str')
``````
===== Arguments
- #raw("value: 'f64'") =\> value to transform
- #raw("transformation: '& str'") =\> transformation function, can be one of log/log10/sqrt
#par()[map values from the attribute based on the given table]
==== float \_div { \#env.float \_div }
``````sig
env attributes.float_div(value1: 'f64', value2: 'f64')
``````
===== Arguments
- #raw("value1: 'f64'") =\> numerator
- #raw("value2: 'f64'") =\> denominator
#par()[map values from the attribute based on the given table]
==== float \_mult { \#env.float \_mult }
``````sig
env attributes.float_mult(value1: 'f64', value2: 'f64')
``````
===== Arguments
- #raw("value1: 'f64'") =\> numerator
- #raw("value2: 'f64'") =\> denominator
#par()[map values from the attribute based on the given table]
=== Node Functions
``````sig
node attributes.load_attrs(filename: 'PathBuf')
``````
===== Arguments
- #raw("filename: 'PathBuf'") =\> Template for the filename to load node attributes from
#par()[Loads attrs from file for all nodes based on the given template]
===== Arguments
- #raw("filename"): Template for the filename to load node attributes from
- #raw("verbose"): print verbose message
#par()[The template will be rendered for each node, and that filename from the rendered template will be used to load the attributes.]
===== Errors
#par()[The function will error out in following conditions:]
- Template for filename is not given,
- The template couldn't be rendered,
- There was error loading attributes from the file.
==== print \_all \_attrs { \#node.print \_all \_attrs }
``````sig
node attributes.print_all_attrs()
``````
===== Arguments
#par()[Print all attrs in a node]
#par()[No arguments and no errors, it'll just print all the attributes in a node with #raw("node::attr=val") format, where,]
- node is node name
- attr is attribute name
- val is attribute value (string representation)
==== print \_attrs { \#node.print \_attrs }
``````sig
node attributes.print_attrs(*attrs, name: 'bool' = false)
``````
===== Arguments
- #raw("*attrs") =\>
- #raw("name: 'bool' = false") =\>
#par()[Print the given node attributes if present]
===== Arguments
- attrs,... : list of attributes to print
- name: Bool for whether to show the node name or not
===== Error
#par()[The function will error if]
- list of arguments are not #raw("String")
- the #raw("name") argument is not Boolean
#par()[The attributes will be printed in #raw("key=val") format.]
==== set \_attrs { \#node.set \_attrs }
``````sig
node attributes.set_attrs(**attrs)
``````
===== Arguments
- #raw("**attrs") =\> Key value pairs of the attributes to set
#par()[Set node attributes]
#par()[Use this function to set the node attributes of all nodes, or a select few nodes using the node selection methods (path or list of nodes)]
===== Error
#par()[The function should not error.]
===== Example
#par()[Following will set the attribute #raw("a2d") to #raw("true") for all nodes from #raw("A") to #raw("D")]
``````task
node[A -> D] set_attrs(a2d = true)
``````
==== get \_attr { \#node.get \_attr }
``````sig
node attributes.get_attr(attr: '& str', default: 'Option < Attribute >')
``````
===== Arguments
- #raw("attr: '& str'") =\> Name of the attribute to get
- #raw("default: 'Option < Attribute >'") =\> Default value if the attribute is not found
#par()[Retrive attribute]
==== has \_attr { \#node.has \_attr }
``````sig
node attributes.has_attr(attr: '& str')
``````
===== Arguments
- #raw("attr: '& str'") =\> Name of the attribute to check
#par()[Check if the attribute is present]
==== first \_attr { \#node.first \_attr }
``````sig
node attributes.first_attr(attrs: '& [String]', default: 'Option < Attribute >')
``````
===== Arguments
- #raw("attrs: '& [String]'") =\> attribute names
- #raw("default: 'Option < Attribute >'") =\> Default value if not found
#par()[Return the first Attribute that exists]
==== set \_attrs \_ifelse { \#node.set \_attrs \_ifelse }
``````sig
node attributes.set_attrs_ifelse(cond: 'bool', **values)
``````
===== Arguments
- #raw("cond: 'bool'") =\> Condition to check
- #raw("**values") =\> key = [val1, val2] where key is set as first if #raw("cond") is true else second
#par()[if else condition with multiple attributes]
==== set \_attrs \_render { \#node.set \_attrs \_render }
``````sig
node attributes.set_attrs_render(**kwargs)
``````
===== Arguments
- #raw("**kwargs") =\> key value pair of attribute to set and the Template to render
#par()[Set node attributes based on string templates]
==== load \_toml \_render { \#node.load \_toml \_render }
``````sig
node attributes.load_toml_render(toml: '& Template', echo: 'bool' = false)
``````
===== Arguments
- #raw("toml: '& Template'") =\> String template to render and load as TOML string
- #raw("echo: 'bool' = false") =\> Print the rendered toml or not
#par()[Set node attributes based on string templates]
=== Network Functions
``````sig
network attributes.set_attrs(**attrs)
``````
===== Arguments
- #raw("**attrs") =\> key value pair of attributes to set
#par()[Set network attributes]
===== Arguments
- #raw("key=value") - Kwargs of attr = value
==== set \_attrs \_render { \#network.set \_attrs \_render }
``````sig
network attributes.set_attrs_render(**kwargs)
``````
===== Arguments
- #raw("**kwargs") =\> Kwargs of attr = String template to render
#par()[Set network attributes based on string templates]

== Command <plugins-command>
==== command <plugins-command-node.command>
``````sig
node command.command(
    cmd: '& Template',
    verbose: 'bool' = true,
    echo: 'bool' = false
)
``````
===== Arguments
- #raw("cmd: '& Template'") =\> String Command template to run
- #raw("verbose: 'bool' = true") =\> Show the rendered version of command, and other messages
- #raw("echo: 'bool' = false") =\> Echo the stdout from the command
#par()[Run the given template as a shell command.]
#par()[Run any command in the shell. The standard output of the command will be consumed and if there are lines starting with #raw("nadi:var:") and followed by #raw("key=val") pairs, it'll be read as new attributes to that node.]
#par()[For example if a command writes #raw("nadi:var:name=\"Joe\"") to stdout, then the for the current node the command is being run for, #raw("name") attribute will be set to #raw("Joe"). This way, you can write your scripts in any language and pass the values back to the NADI system.]
#par()[It will also print out the new values or changes from old values, if #raw("verbose") is true.]
===== Errors
#par()[The function will error if,]
- The command template cannot be rendered,
- The command cannot be executed,
- The attributes from command's stdout cannot be parsed properly
==== run { \#node.run }
``````sig
node command.run(
    command: '& str',
    inputs: '& str',
    outputs: '& str',
    verbose: 'bool' = true,
    echo: 'bool' = false
)
``````
===== Arguments
- #raw("command: '& str'") =\> Node Attribute with the command to run
- #raw("inputs: '& str'") =\> Node attribute with list of input files
- #raw("outputs: '& str'") =\> Node attribute with list of output files
- #raw("verbose: 'bool' = true") =\> Print the command being run
- #raw("echo: 'bool' = false") =\> Show the output of the command
#par()[Run the node as if it's a command if inputs are changed]
#par()[This function will not run a command node if all outputs are older than all inputs. This is useful to networks where each nodes are tasks with input files and output files.]
=== Network Functions
``````sig
network command.parallel(
    cmd: '& Template',
    _workers: 'i64' = 4,
    verbose: 'bool' = true,
    echo: 'bool' = false
)
``````
===== Arguments
- #raw("cmd: '& Template'") =\> String Command template to run
- #raw("_workers: 'i64' = 4") =\> Number of workers to run in parallel
- #raw("verbose: 'bool' = true") =\> Print the command being run
- #raw("echo: 'bool' = false") =\> Show the output of the command
#par()[Run the given template as a shell command for each nodes in the network in parallel.]
===== Warning
#par()[Currently there is no way to limit the number of parallel processes, so please be careful with this command if you have very large number of nodes.]
==== command <plugins-command-network.command>
``````sig
network command.command(
    cmd: 'Template',
    verbose: 'bool' = true,
    echo: 'bool' = false
)
``````
===== Arguments
- #raw("cmd: 'Template'") =\> String Command template to run
- #raw("verbose: 'bool' = true") =\> Print the command being run
- #raw("echo: 'bool' = false") =\> Show the output of the command
#par()[Run the given template as a shell command.]
#par()[Run any command in the shell. The standard output of the command will be consumed and if there are lines starting with #raw("nadi:var:") and followed by #raw("key=val") pairs, it'll be read as new attributes to that node.]
#par()[See #raw("node command.command") for more details as they have the same implementation]

== Connections
==== load \_file { \#network.load \_file }
``````sig
network connections.load_file(file: 'PathBuf', append: 'bool' = false)
``````
===== Arguments
- #raw("file: 'PathBuf'") =\> File to load the network connections from
- #raw("append: 'bool' = false") =\> Append the connections in the current network
#par()[Load the given file into the network]
#par()[This replaces the current network with the one loaded from the file.]
==== load \_str { \#network.load \_str }
``````sig
network connections.load_str(contents: '& str', append: 'bool' = false)
``````
===== Arguments
- #raw("contents: '& str'") =\> String containing Network connections
- #raw("append: 'bool' = false") =\> Append the connections in the current network
#par()[Load the given file into the network]
#par()[This replaces the current network with the one loaded from the file.]
==== load \_edges { \#network.load \_edges }
``````sig
network connections.load_edges(edges: '& [(String, String)]', append: 'bool' = false)
``````
===== Arguments
- #raw("edges: '& [(String, String)]'") =\> String containing Network connections
- #raw("append: 'bool' = false") =\> Append the connections in the current network
#par()[Load the given edges into the network]
#par()[This replaces the current network with the one loaded from the file.]
==== subset { \#network.subset }
``````sig
network connections.subset(filter: '& [bool]', keep: 'bool' = true)
``````
===== Arguments
- #raw("filter: '& [bool]'") =\>
- #raw("keep: 'bool' = true") =\> Keep the selected nodes (false = removes the selected)
#par()[Take a subset of network by only including the selected nodes]
==== save \_file { \#network.save \_file }
``````sig
network connections.save_file(
    file: 'PathBuf',
    quote_all: 'bool' = true,
    graphviz: 'bool' = false
)
``````
===== Arguments
- #raw("file: 'PathBuf'") =\> Path to the output file
- #raw("quote_all: 'bool' = true") =\> quote all node names; if false, doesn't quote valid identifier names
- #raw("graphviz: 'bool' = false") =\> wrap the network into a valid graphviz file
#par()[Save the network into the given file]
#par()[For more control on graphviz file writing use #raw("save_graphviz") from #raw("graphviz") plugin instead.]

== Core
==== count { \#env.count }
``````sig
env core.count(vars: '& [bool]')
``````
===== Arguments
- #raw("vars: '& [bool]'") =\>
#par()[Count the number of true values in the array]
==== type \_name { \#env.type \_name }
``````sig
env core.type_name(value: 'Attribute', recursive: 'bool' = false)
``````
===== Arguments
- #raw("value: 'Attribute'") =\> Argument to get type
- #raw("recursive: 'bool' = false") =\> Recursively check types for array and table
#par()[Type name of the arguments]
==== isna { \#env.isna }
``````sig
env core.isna(val: 'f64')
``````
===== Arguments
- #raw("val: 'f64'") =\>
#par()[check if a float is nan]
==== isinf { \#env.isinf }
``````sig
env core.isinf(val: 'f64')
``````
===== Arguments
- #raw("val: 'f64'") =\>
#par()[check if a float is +/- infinity]
==== float { \#env.float }
``````sig
env core.float(value: 'Attribute', parse: 'bool' = true)
``````
===== Arguments
- #raw("value: 'Attribute'") =\> Argument to convert to float
- #raw("parse: 'bool' = true") =\> parse string to float
#par()[make a float from value]
==== str { \#env.str }
``````sig
env core.str(value: 'Attribute', quote: 'bool' = false)
``````
===== Arguments
- #raw("value: 'Attribute'") =\> Argument to convert to float
- #raw("quote: 'bool' = false") =\> quote it if it's literal string
#par()[make a string from value]
==== int { \#env.int }
``````sig
env core.int(
    value: 'Attribute',
    parse: 'bool' = true,
    round: 'bool' = true,
    strfloat: 'bool' = false
)
``````
===== Arguments
- #raw("value: 'Attribute'") =\> Argument to convert to int
- #raw("parse: 'bool' = true") =\> parse string to int
- #raw("round: 'bool' = true") =\> round float into integer
- #raw("strfloat: 'bool' = false") =\> parse string first as float before converting to int
#par()[make an int from the value]
==== array { \#env.array }
``````sig
env core.array(*attributes)
``````
===== Arguments
- #raw("*attributes") =\> List of attributes
#par()[make an array from the arguments]
==== attrmap { \#env.attrmap }
``````sig
env core.attrmap(**attributes)
``````
===== Arguments
- #raw("**attributes") =\> name and values of attributes
#par()[make an array from the arguments]
==== append { \#env.append }
``````sig
env core.append(array: 'Vec < Attribute >', value: 'Attribute')
``````
===== Arguments
- #raw("array: 'Vec < Attribute >'") =\> List of attributes
- #raw("value: 'Attribute'") =\>
#par()[append a value to an array]
==== length { \#env.length }
``````sig
env core.length(value: '& Attribute')
``````
===== Arguments
- #raw("value: '& Attribute'") =\> Array or a HashMap
#par()[length of an array or hashmap]
==== year { \#env.year }
``````sig
env core.year(value: 'Attribute')
``````
===== Arguments
- #raw("value: 'Attribute'") =\> Date or DateTime
#par()[year from date/datetime]
==== month { \#env.month }
``````sig
env core.month(value: 'Attribute')
``````
===== Arguments
- #raw("value: 'Attribute'") =\> Date or DateTime
#par()[month from date/datetime]
==== day { \#env.day }
``````sig
env core.day(value: 'Attribute')
``````
===== Arguments
- #raw("value: 'Attribute'") =\> Date or DateTime
#par()[day from date/datetime]
==== min \_num { \#env.min \_num }
``````sig
env core.min_num(vars: 'Vec < Attribute >', start: 'Attribute' = Integer(9223372036854775807))
``````
===== Arguments
- #raw("vars: 'Vec < Attribute >'") =\>
- #raw("start: 'Attribute' = Integer(9223372036854775807)") =\>
#par()[Minimum of the variables]
#par()[Starts with integer for type purpose, MAX float is larger than max int, so it'll be incorrect for large numbers]
==== max \_num { \#env.max \_num }
``````sig
env core.max_num(vars: 'Vec < Attribute >', start: 'Attribute' = Integer(-9223372036854775808))
``````
===== Arguments
- #raw("vars: 'Vec < Attribute >'") =\>
- #raw("start: 'Attribute' = Integer(-9223372036854775808)") =\>
#par()[Minimum of the variables]
#par()[Starts with integer for type purpose, MAX float is larger than max int, so it'll be incorrect for large numbers]
==== min { \#env.min }
``````sig
env core.min(vars: 'Vec < Attribute >', start: 'Attribute')
``````
===== Arguments
- #raw("vars: 'Vec < Attribute >'") =\>
- #raw("start: 'Attribute'") =\>
#par()[Minimum of the variables]
==== max { \#env.max }
``````sig
env core.max(vars: 'Vec < Attribute >', start: 'Attribute')
``````
===== Arguments
- #raw("vars: 'Vec < Attribute >'") =\>
- #raw("start: 'Attribute'") =\>
#par()[Minimum of the variables]
==== sum { \#env.sum }
``````sig
env core.sum(vars: 'Vec < Attribute >', start: 'Attribute' = Integer(0))
``````
===== Arguments
- #raw("vars: 'Vec < Attribute >'") =\>
- #raw("start: 'Attribute' = Integer(0)") =\>
#par()[Sum of the variables]
==== prod { \#env.prod }
``````sig
env core.prod(vars: 'Vec < Attribute >', start: 'Attribute' = Integer(1))
``````
===== Arguments
- #raw("vars: 'Vec < Attribute >'") =\>
- #raw("start: 'Attribute' = Integer(1)") =\>
#par()[Product of the variables]
==== unique \_str { \#env.unique \_str }
``````sig
env core.unique_str(vars: 'Vec < String >')
``````
===== Arguments
- #raw("vars: 'Vec < String >'") =\>
#par()[Get a list of unique string values]
==== count \_str { \#env.count \_str }
``````sig
env core.count_str(vars: 'Vec < String >')
``````
===== Arguments
- #raw("vars: 'Vec < String >'") =\>
#par()[Get a count of unique string values]
==== concat { \#env.concat }
``````sig
env core.concat(*vars, join: '& str' = "")
``````
===== Arguments
- #raw("*vars") =\>
- #raw("join: '& str' = \"\"") =\>
#par()[Concat the strings]
=== Node Functions
``````sig
node core.inputs_count()
``````
===== Arguments
#par()[Count the number of input nodes in the node]
==== inputs \_attr { \#node.inputs \_attr }
``````sig
node core.inputs_attr(attr: 'String' = "NAME")
``````
===== Arguments
- #raw("attr: 'String' = \"NAME\"") =\> Attribute to get from inputs
#par()[Get attributes of the input nodes]
==== has \_outlet { \#node.has \_outlet }
``````sig
node core.has_outlet()
``````
===== Arguments
#par()[Node has an outlet or not]
==== output \_attr { \#node.output \_attr }
``````sig
node core.output_attr(attr: 'String' = "NAME")
``````
===== Arguments
- #raw("attr: 'String' = \"NAME\"") =\> Attribute to get from inputs
#par()[Get attributes of the output node]
=== Network Functions
``````sig
network core.count(vars: 'Option < Vec < bool > >')
``````
===== Arguments
- #raw("vars: 'Option < Vec < bool > >'") =\>
#par()[Count the number of nodes in the network]

== Debug
==== sleep { \#env.sleep }
``````sig
env debug.sleep(time: 'u64' = 1000)
``````
===== Arguments
- #raw("time: 'u64' = 1000") =\>
#par()[sleep for given number of milliseconds]
==== debug { \#env.debug }
``````sig
env debug.debug(*args, **kwargs)
``````
===== Arguments
- #raw("*args") =\> Function arguments
- #raw("**kwargs") =\> Function Keyword arguments
#par()[Print the args and kwargs on this function]
#par()[This function will just print out the args and kwargs the function is called with. This is for debugging purposes to see if the args/kwargs are identified properly. And can also be used to see how the nadi system takes the input from the function call.]
==== echo { \#env.echo }
``````sig
env debug.echo(
    line: 'String',
    error: 'bool' = false,
    newline: 'bool' = true
)
``````
===== Arguments
- #raw("line: 'String'") =\> line to print
- #raw("error: 'bool' = false") =\> print to stderr instead of stdout
- #raw("newline: 'bool' = true") =\> print newline at the end
#par()[Echo the string to stdout or stderr]
#par()[This simply echoes anything given to it. This can be used in combination with nadi tasks that create files (image, text, etc). The #raw("echo") function can be called to get the link to those files back to the stdout.]
#par()[Also useful for nadi preprocessor.]
==== clip { \#env.clip }
``````sig
env debug.clip(error: 'bool' = false)
``````
===== Arguments
- #raw("error: 'bool' = false") =\> print in stderr instead of in stdout
#par()[Echo the ----8\<---- line for clipping syntax]
#par()[This function is a utility function for the generation of nadi book. This prints out the #raw("----8<----") line when called, so that #raw("mdbook") preprocessor for #raw("nadi") knows where to clip the output for displaying it in the book.]
#par()[This makes it easier to only show the relevant parts of the output in the documentation instead of having the user see output of other unrelated parts which are necessary for generating the results.]
===== Example
#par()[Given the following tasks file:]
``````task
net load_file("...")
net load_attrs("...")
net clip()
net render("{_NAME} {attr1}")
``````
#par()[The clip function's output will let the preprocessor know that only the parts after that are relevant to the user. Hence, it'll discard outputs before that during documentation generation.]

== Logic
==== ifelse { \#env.ifelse }
``````sig
env logic.ifelse(
    cond: 'bool',
    iftrue: 'Attribute',
    iffalse: 'Attribute'
)
``````
===== Arguments
- #raw("cond: 'bool'") =\> Attribute that can be cast to bool value
- #raw("iftrue: 'Attribute'") =\> Output if #raw("cond") is true
- #raw("iffalse: 'Attribute'") =\> Output if #raw("cond") is false
#par()[Simple if else condition]
==== gt { \#env.gt }
``````sig
env logic.gt(a: '& Attribute', b: '& Attribute')
``````
===== Arguments
- #raw("a: '& Attribute'") =\> first attribute
- #raw("b: '& Attribute'") =\> second attribute
#par()[Greater than check]
==== lt { \#env.lt }
``````sig
env logic.lt(a: '& Attribute', b: '& Attribute')
``````
===== Arguments
- #raw("a: '& Attribute'") =\> first attribute
- #raw("b: '& Attribute'") =\> second attribute
#par()[Greater than check]
==== eq { \#env.eq }
``````sig
env logic.eq(a: '& Attribute', b: '& Attribute')
``````
===== Arguments
- #raw("a: '& Attribute'") =\> first attribute
- #raw("b: '& Attribute'") =\> second attribute
#par()[Greater than check]
==== and { \#env.and }
``````sig
env logic.and(*conds)
``````
===== Arguments
- #raw("*conds") =\> List of attributes that can be cast to bool
#par()[Boolean and]
==== or { \#env.or }
``````sig
env logic.or(*conds)
``````
===== Arguments
- #raw("*conds") =\> List of attributes that can be cast to bool
#par()[boolean or]
==== not { \#env.not }
``````sig
env logic.not(cond: 'bool')
``````
===== Arguments
- #raw("cond: 'bool'") =\> attribute that can be cast to bool
#par()[boolean not]
==== all { \#env.all }
``````sig
env logic.all(vars: '& [bool]')
``````
===== Arguments
- #raw("vars: '& [bool]'") =\>
#par()[check if all of the bool are true]
==== any { \#env.any }
``````sig
env logic.any(vars: '& [bool]')
``````
===== Arguments
- #raw("vars: '& [bool]'") =\>
#par()[check if any of the bool are true]

== Regex
==== str \_filter { \#env.str \_filter }
``````sig
env regex.str_filter(attrs: 'Vec < String >', pattern: 'Regex')
``````
===== Arguments
- #raw("attrs: 'Vec < String >'") =\> attribute to check for pattern
- #raw("pattern: 'Regex'") =\> Regex pattern to match
#par()[Check if the given pattern matches the value or not]
==== str \_match { \#env.str \_match }
``````sig
env regex.str_match(attr: '& str', pattern: 'Regex')
``````
===== Arguments
- #raw("attr: '& str'") =\> attribute to check for pattern
- #raw("pattern: 'Regex'") =\> Regex pattern to match
#par()[Check if the given pattern matches the value or not]
#par()[You can also use match operator for this]
==== str \_replace { \#env.str \_replace }
``````sig
env regex.str_replace(
    attr: '& str',
    pattern: 'Regex',
    rep: '& str'
)
``````
===== Arguments
- #raw("attr: '& str'") =\> original string
- #raw("pattern: 'Regex'") =\> Regex pattern to match
- #raw("rep: '& str'") =\> replacement string
#par()[Replace the occurances of the given match]
==== str \_find { \#env.str \_find }
``````sig
env regex.str_find(attr: '& str', pattern: 'Regex')
``````
===== Arguments
- #raw("attr: '& str'") =\> attribute to check for pattern
- #raw("pattern: 'Regex'") =\> Regex pattern to match
#par()[Find the given pattern in the value]
==== str \_find \_all { \#env.str \_find \_all }
``````sig
env regex.str_find_all(attr: '& str', pattern: 'Regex')
``````
===== Arguments
- #raw("attr: '& str'") =\> attribute to check for pattern
- #raw("pattern: 'Regex'") =\> Regex pattern to match
#par()[Find all the matches of the given pattern in the value]
==== str \_count { \#env.str \_count }
``````sig
env regex.str_count(attr: '& str', pattern: 'Regex')
``````
===== Arguments
- #raw("attr: '& str'") =\> attribute to check for pattern
- #raw("pattern: 'Regex'") =\> Regex pattern to match
#par()[Count the number of matches of given pattern in the value]

== Render
==== render { \#env.render }
``````sig
env render.render(
    template: '& Template',
    **keyval,
    safe: 'bool' = false
)
``````
===== Arguments
- #raw("template: '& Template'") =\> String template to render
- #raw("**keyval") =\>
- #raw("safe: 'bool' = false") =\> if render fails keep it as it is instead of exiting
#par()[Render the template based on the node attributes]
#par()[For more details on the template system. Refer to the String Template section of the NADI book.]
=== Node Functions
``````sig
node render.render(template: '& Template', safe: 'bool' = false)
``````
===== Arguments
- #raw("template: '& Template'") =\> String template to render
- #raw("safe: 'bool' = false") =\> if render fails keep it as it is instead of exiting
#par()[Render the template based on the node attributes]
#par()[For more details on the template system. Refer to the String Template section of the NADI book.]
=== Network Functions
``````sig
network render.render(template: '& Template', safe: 'bool' = false)
``````
===== Arguments
- #raw("template: '& Template'") =\> Path to the template file
- #raw("safe: 'bool' = false") =\> if render fails keep it as it is instead of exiting
#par()[Render from network attributes]
==== render \_nodes { \#network.render \_nodes }
``````sig
network render.render_nodes(
    template: '& Template',
    safe: 'bool' = false,
    join: '& str' = "\n"
)
``````
===== Arguments
- #raw("template: '& Template'") =\> Path to the template file
- #raw("safe: 'bool' = false") =\> if render fails keep it as it is instead of exiting
- #raw("join: '& str' = \"\\n\"") =\> String to join the render results
#par()[Render each node of the network and combine to same variable]
==== render \_template { \#network.render \_template }
``````sig
network render.render_template(template: 'PathBuf')
``````
===== Arguments
- #raw("template: 'PathBuf'") =\> Path to the template file
#par()[Render a File template for the nodes in the whole network]
#par()[Write the file with templates for input variables in the same way you write string templates. It's useful for markdown files, as the curly braces syntax won't be used for anything else that way. Do be careful about that. And the program will replace those templates with their values when you run it with inputs.]
#par()[It'll repeat the same template for each node and render them. If you want only a portion of the file repeated for nodes inclose them with lines with #raw("---8<---") on both start and the end. The lines containing the clip syntax will be ignored, ideally you can put them in comments.]
#par()[You can also use #raw("---include:<filename>[::line_range]") syntax to include a file, the line \_range syntax, if present, should be in the form of #raw("start[:increment]:end"), you can exclude start or end to denote the line 1 or last line (e.g. #raw(":5") is 1:5, and #raw("3:") is from line 3 to the end)]
===== Arguments
- #raw("template"): Path to the template file
- #raw("outfile") [Optional]: Path to save the template file, if none it'll be printed in stdout

== Series
==== sr \_count { \#node.sr \_count }
``````sig
node series.sr_count()
``````
===== Arguments
#par()[Number of series in the node]
==== sr \_list { \#node.sr \_list }
``````sig
node series.sr_list()
``````
===== Arguments
#par()[List all series in the node]
==== sr \_dtype { \#node.sr \_dtype }
``````sig
node series.sr_dtype(name: '& str', safe: 'bool' = false)
``````
===== Arguments
- #raw("name: '& str'") =\> Name of the series
- #raw("safe: 'bool' = false") =\> Do not error if series does't exist
#par()[Type name of the series]
==== sr \_len { \#node.sr \_len }
``````sig
node series.sr_len(name: '& str', safe: 'bool' = false)
``````
===== Arguments
- #raw("name: '& str'") =\> Name of the series
- #raw("safe: 'bool' = false") =\> Do not error if series does't exist
#par()[Length of the series]
==== sr \_mean { \#node.sr \_mean }
``````sig
node series.sr_mean(name: '& str')
``````
===== Arguments
- #raw("name: '& str'") =\> Name of the series
#par()[Type name of the series]
==== sr \_sum { \#node.sr \_sum }
``````sig
node series.sr_sum(name: '& str')
``````
===== Arguments
- #raw("name: '& str'") =\> Name of the series
#par()[Sum of the series]
==== set \_series { \#node.set \_series }
``````sig
node series.set_series(
    name: '& str',
    value: 'Attribute',
    dtype: '& str'
)
``````
===== Arguments
- #raw("name: '& str'") =\> Name of the series to save as
- #raw("value: 'Attribute'") =\> Argument to convert to series
- #raw("dtype: '& str'") =\> type
#par()[set the following series to the node]
==== sr \_to \_array { \#node.sr \_to \_array }
``````sig
node series.sr_to_array(name: '& str', safe: 'bool' = false)
``````
===== Arguments
- #raw("name: '& str'") =\> Name of the series
- #raw("safe: 'bool' = false") =\> Do not error if series does't exist
#par()[Make an array from the series]

== Table
==== save \_csv { \#network.save \_csv }
``````sig
network table.save_csv(
    path: '& Path',
    fields: '& [String]',
    filter: 'Option < Vec < bool > >'
)
``````
===== Arguments
- #raw("path: '& Path'") =\>
- #raw("fields: '& [String]'") =\>
- #raw("filter: 'Option < Vec < bool > >'") =\>
#par()[Save CSV]
==== table \_to \_markdown { \#network.table \_to \_markdown }
``````sig
network table.table_to_markdown(
    table: 'Option < PathBuf >',
    template: 'Option < String >',
    outfile: 'Option < PathBuf >',
    connections: 'Option < String >'
)
``````
===== Arguments
- #raw("table: 'Option < PathBuf >'") =\> Path to the table file
- #raw("template: 'Option < String >'") =\> String template for table
- #raw("outfile: 'Option < PathBuf >'") =\> Path to the output file
- #raw("connections: 'Option < String >'") =\> Show connections column or not
#par()[Render the Table as a rendered markdown]
===== Error
#par()[The function will error out if,]
- error reading the table file,
- error parsing table template,
- neither one of table file or table template is provided,
- error while rendering markdown (caused by error on rendering cell values from templates)
- error while writing to the output file

== Timeseries
==== ts \_count { \#node.ts \_count }
``````sig
node timeseries.ts_count()
``````
===== Arguments
#par()[Number of timeseries in the node]
==== ts \_list { \#node.ts \_list }
``````sig
node timeseries.ts_list()
``````
===== Arguments
#par()[List all timeseries in the node]
==== ts \_dtype { \#node.ts \_dtype }
``````sig
node timeseries.ts_dtype(name: '& str', safe: 'bool' = false)
``````
===== Arguments
- #raw("name: '& str'") =\> Name of the timeseries
- #raw("safe: 'bool' = false") =\> Do not error if timeseries does't exist
#par()[Type name of the timeseries]
==== ts \_len { \#node.ts \_len }
``````sig
node timeseries.ts_len(name: '& str', safe: 'bool' = false)
``````
===== Arguments
- #raw("name: '& str'") =\> Name of the timeseries
- #raw("safe: 'bool' = false") =\> Do not error if timeseries does't exist
#par()[Length of the timeseries]
==== ts \_print { \#node.ts \_print }
``````sig
node timeseries.ts_print(
    name: '& String',
    header: 'bool' = true,
    head: 'Option < i64 >'
)
``````
===== Arguments
- #raw("name: '& String'") =\> name of the timeseries
- #raw("header: 'bool' = true") =\> show header
- #raw("head: 'Option < i64 >'") =\> number of head rows to show (all by default)
#par()[Print the given timeseries values in csv format]
===== TODO
- save to file instead of showing with #raw("outfile: Option<PathBuf>")
=== Network Functions
``````sig
network timeseries.ts_print_csv(
    name: 'String',
    head: 'Option < usize >',
    nodes: 'Option < HashSet < String > >'
)
``````
===== Arguments
- #raw("name: 'String'") =\> Name of the timeseries to save
- #raw("head: 'Option < usize >'") =\> number of head rows to show (all by default)
- #raw("nodes: 'Option < HashSet < String > >'") =\> Include only these nodes (all by default)
#par()[Save timeseries from all nodes into a single csv file]
#par()[TODO: error/not on unqual length TODO: error/not on no timeseries, etc... TODO: output to #raw("file: PathBuf")]
==== series \_csv { \#network.series \_csv }
``````sig
network timeseries.series_csv(
    filter: 'Vec < bool >',
    outfile: 'PathBuf',
    attrs: 'Vec < String >',
    series: 'Vec < String >'
)
``````
===== Arguments
- #raw("filter: 'Vec < bool >'") =\>
- #raw("outfile: 'PathBuf'") =\> Path to the output csv
- #raw("attrs: 'Vec < String >'") =\> list of attributes to write
- #raw("series: 'Vec < String >'") =\> list of series to write
#par()[Write the given nodes to csv with given attributes and series]

== Visuals
==== set \_nodesize \_attrs { \#network.set \_nodesize \_attrs }
``````sig
network visuals.set_nodesize_attrs(
    attrs: '& [f64]',
    minsize: 'f64' = 4.0,
    maxsize: 'f64' = 12.0
)
``````
===== Arguments
- #raw("attrs: '& [f64]'") =\> Attribute values to use for size scaling
- #raw("minsize: 'f64' = 4.0") =\> minimum size of the node
- #raw("maxsize: 'f64' = 12.0") =\> maximum size of the node
#par()[Set the node size of the nodes based on the attribute value]
==== svg \_save { \#network.svg \_save }
``````sig
network visuals.svg_save(
    outfile: '& Path',
    label: 'Template' = Template { original: "{_NAME}", parts: [Var("_NAME", "")] },
    x_spacing: 'u64' = 25,
    y_spacing: 'u64' = 25,
    offset: 'u64' = 10,
    twidth: 'f64' = 9.0,
    width: 'u64' = 500,
    height: 'u64' = 240,
    bgcolor: 'Option < String >',
    page_width: 'Option < u64 >',
    page_height: 'Option < u64 >'
)
``````
===== Arguments
- #raw("outfile: '& Path'") =\>
- #raw("label: 'Template' = Template { original: \"{_NAME}\", parts: [Var(\"_NAME\", \"\")] }") =\>
- #raw("x_spacing: 'u64' = 25") =\>
- #raw("y_spacing: 'u64' = 25") =\>
- #raw("offset: 'u64' = 10") =\>
- #raw("twidth: 'f64' = 9.0") =\> in average how many units each text character takes
#par()[For auto calculating width of the page since we don't have Cairo]
- #raw("width: 'u64' = 500") =\>
- #raw("height: 'u64' = 240") =\>
- #raw("bgcolor: 'Option < String >'") =\>
- #raw("page_width: 'Option < u64 >'") =\>
- #raw("page_height: 'Option < u64 >'") =\>
#par()[Exports the network as a svg]
#pagebreak(weak: true)
#pagebreak(weak: true)
#pagebreak(weak: true)
= External Plugins
#par()[This section showcases the functions from external plugins developed along side the NADI project due to various reasons.]
#par()[The plugins listed here can be installed with following steps:]
- clone the repository of external plugins,
- compile it locally with cargo,
- move all generated dynamic libraries to the nadi plugin directory.
== Dams
==== count \_node \_if { \#node.count \_node \_if }
``````sig
node dams.count_node_if(count_attr: '& str', cond: 'bool')
``````
===== Arguments
- #raw("count_attr: '& str'") =\>
- #raw("cond: 'bool'") =\>
#par()[Count the number of nodes upstream at each point that satisfies a certain condition]
==== min \_year { \#node.min \_year }
``````sig
node dams.min_year(yearattr: '& str', write_var: '& str' = "MIN_YEAR")
``````
===== Arguments
- #raw("yearattr: '& str'") =\>
- #raw("write_var: '& str' = \"MIN_YEAR\"") =\>
#par()[Propagate the minimum year downstream]

== Data Fill
==== load \_csv \_fill { \#node.load \_csv \_fill }
``````sig
node datafill.load_csv_fill(
    name: 'String',
    file: 'Template',
    timefmt: 'String',
    columns: '(String, String)',
    method: 'DataFillMethod' = Linear,
    dtype: 'String' = "Floats"
)
``````
===== Arguments
- #raw("name: 'String'") =\> Name of the timeseries
- #raw("file: 'Template'") =\> Template of the CSV file for the nodes
- #raw("timefmt: 'String'") =\> date time format, if you only have date, but have time on format string, it will panic
- #raw("columns: '(String, String)'") =\> Names of date column and value column
- #raw("method: 'DataFillMethod' = Linear") =\> Method to use for data filling: forward/backward/linear
- #raw("dtype: 'String' = \"Floats\"") =\> DataType to load into timeseries
==== datafill \_experiment { \#node.datafill \_experiment }
``````sig
node datafill.datafill_experiment(
    name: 'String',
    file: 'Template',
    ratio_var: 'String',
    columns: 'Option < (String, String) >',
    experiments: 'usize' = 10,
    samples: 'usize' = 100
)
``````
===== Arguments
- #raw("name: 'String'") =\> Prefix for name of the series to save metrics on
- #raw("file: 'Template'") =\> Template of the CSV file for the nodes
- #raw("ratio_var: 'String'") =\> Variable to use for inputratio/outputratio methods
- #raw("columns: 'Option < (String, String) >'") =\> Names of date column and value column
- #raw("experiments: 'usize' = 10") =\> Number of experiements to run
- #raw("samples: 'usize' = 100") =\> Number of samples on each experiment
=== Network Functions
``````sig
network datafill.save_experiments_csv(
    outfile: 'PathBuf',
    attrs: 'Vec < String >',
    prefix: 'String',
    errors: 'Vec < String >',
    filter: 'Option < Vec < bool > >'
)
``````
===== Arguments
- #raw("outfile: 'PathBuf'") =\> Path to the output csv
- #raw("attrs: 'Vec < String >'") =\> list of attributes to write
- #raw("prefix: 'String'") =\> Prefix
- #raw("errors: 'Vec < String >'") =\> list of errors to write
- #raw("filter: 'Option < Vec < bool > >'") =\>
#par()[Write the given nodes to csv with given attributes and experiment results]

== Errors
==== calc \_ts \_error { \#node.calc \_ts \_error }
``````sig
node errors.calc_ts_error(
    ts1: '& str',
    ts2: '& str',
    error: '& str' = "rmse"
)
``````
===== Arguments
- #raw("ts1: '& str'") =\> Timeseries value to use as actual value
- #raw("ts2: '& str'") =\> Timeseries value to be used to calculate the error
- #raw("error: '& str' = \"rmse\"") =\> Error type, one of rmse/nrmse/abserr/nse
#par()[Calculate Error from two timeseries values in the node]
#par()[It calculates the error between two timeseries values from the node]
==== calc \_ts \_errors { \#node.calc \_ts \_errors }
``````sig
node errors.calc_ts_errors(
    ts1: '& String',
    ts2: '& String',
    errors: '& [String]'
)
``````
===== Arguments
- #raw("ts1: '& String'") =\> Timeseries value to use as actual value
- #raw("ts2: '& String'") =\> Timeseries value to be used to calculate the error
- #raw("errors: '& [String]'") =\> Error types to calculate, one of rmse/nrmse/abserr/nse
#par()[Calculate Error from two timeseries values in the node]
#par()[It calculates the error between two timeseries values from the node.]
=== Network Functions
``````sig
network errors.calc_attr_error(
    attr1: 'String',
    attr2: 'String',
    error: 'String' = "rmse"
)
``````
===== Arguments
- #raw("attr1: 'String'") =\> Attribute value to use as actual value
- #raw("attr2: 'String'") =\> Attribute value to be used to calculate the error
- #raw("error: 'String' = \"rmse\"") =\> Error type, one of rmse/nrmse/abserr/nse
#par()[Calculate Error from two attribute values in the network]
#par()[It calculates the error using two attribute values from all the nodes.]

== Fancy Print
==== fancy \_print { \#network.fancy \_print }
``````sig
network fancy_print.fancy_print()
``````
===== Arguments
#par()[Fancy print a network]

== Gnuplot
==== plot \_timeseries { \#network.plot \_timeseries }
``````sig
network gnuplot.plot_timeseries(
    csvfile: 'Template',
    datecol: '& str',
    datacol: '& str',
    outfile: '& Path',
    timefmt: '& str' = "%Y-%m-%d",
    config: '& GnuplotConfig' = GnuplotConfig { outfile: None, terminal: None, csv: false, preamble: "" },
    skip_missing: 'bool' = false
)
``````
===== Arguments
- #raw("csvfile: 'Template'") =\>
- #raw("datecol: '& str'") =\>
- #raw("datacol: '& str'") =\>
- #raw("outfile: '& Path'") =\>
- #raw("timefmt: '& str' = \"%Y-%m-%d\"") =\>
- #raw("config: '& GnuplotConfig' = GnuplotConfig { outfile: None, terminal: None, csv: false, preamble: \"\" }") =\>
- #raw("skip_missing: 'bool' = false") =\>
#par()[Generate a gnuplot file that plots the timeseries data in the network]

== Graphics
=== Node Functions
``````sig
node graphics.attr_fraction_svg(
    attr: '& str',
    outfile: '& Template',
    color: '& AttrColor',
    height: 'f64' = 80.0,
    width: 'f64' = 80.0,
    margin: 'f64' = 10.0
)
``````
===== Arguments
- #raw("attr: '& str'") =\>
- #raw("outfile: '& Template'") =\>
- #raw("color: '& AttrColor'") =\>
- #raw("height: 'f64' = 80.0") =\>
- #raw("width: 'f64' = 80.0") =\>
- #raw("margin: 'f64' = 10.0") =\>
#par()[Create a SVG file with the given network structure]
=== Network Functions
``````sig
network graphics.csv_load_ts(
    file: 'PathBuf',
    name: 'String',
    date_col: 'String' = "date",
    timefmt: 'String' = "%Y-%m-%d",
    data_type: 'String' = "Floats"
)
``````
===== Arguments
- #raw("file: 'PathBuf'") =\>
- #raw("name: 'String'") =\>
- #raw("date_col: 'String' = \"date\"") =\>
- #raw("timefmt: 'String' = \"%Y-%m-%d\"") =\>
- #raw("data_type: 'String' = \"Floats\"") =\>
#par()[Count the number of na values in CSV file for each nodes in a network]
===== Arguments
- #raw("file"): Input CSV file path to read (should have column with node names for all nodes)
- #raw("name"): Name of the timeseries
- #raw("date_col"): Date Column name
- #raw("timefmt"): date time format, if you only have date, but have time on format string, it will panic
- #raw("data_type"): Type of the data to cast into
==== csv \_count \_na { \#network.csv \_count \_na }
``````sig
network graphics.csv_count_na(
    file: 'PathBuf',
    outattr: 'Option < String >',
    sort: 'bool' = false,
    skip_zero: 'bool' = false,
    head: 'Option < i64 >'
)
``````
===== Arguments
- #raw("file: 'PathBuf'") =\>
- #raw("outattr: 'Option < String >'") =\>
- #raw("sort: 'bool' = false") =\>
- #raw("skip_zero: 'bool' = false") =\>
- #raw("head: 'Option < i64 >'") =\>
#par()[Count the number of na values in CSV file for each nodes in a network]
===== Arguments
- #raw("file"): Input CSV file path to read (should have column with node names for all nodes)
- #raw("outattr"): Output attribute to save the count of NA to. If empty print to stdout
- #raw("sort"): show the nodes with larger gaps on top, only applicable while printing
- #raw("head"): at max show only this number of nodes
- #raw("skip_zero"): skip nodes with zero missing numbers
==== csv \_data \_blocks \_svg { \#network.csv \_data \_blocks \_svg }
``````sig
network graphics.csv_data_blocks_svg(
    csvfile: 'PathBuf',
    outfile: 'PathBuf',
    label: 'Template',
    date_col: 'String' = "date",
    config: 'NetworkPlotConfig' = NetworkPlotConfig { width: 250.0, height: 300.0, delta_x: 20.0, delta_y: 20.0, offset: 30.0, radius: 3.0, fontsize: 16.0, fontface: FontFace { inner: Shared { inner: 0x64a7356cd4c0 } } },
    blocks_width: 'f64' = 500.0,
    fit: 'bool' = false
)
``````
===== Arguments
- #raw("csvfile: 'PathBuf'") =\>
- #raw("outfile: 'PathBuf'") =\>
- #raw("label: 'Template'") =\>
- #raw("date_col: 'String' = \"date\"") =\>
- #raw("config: 'NetworkPlotConfig' = NetworkPlotConfig { width: 250.0, height: 300.0, delta_x: 20.0, delta_y: 20.0, offset: 30.0, radius: 3.0, fontsize: 16.0, fontface: FontFace { inner: Shared { inner: 0x64a7356cd4c0 } } }") =\>
- #raw("blocks_width: 'f64' = 500.0") =\>
- #raw("fit: 'bool' = false") =\>
#par()[Draw the data blocks with arrows in timeline]
==== export \_svg { \#network.export \_svg }
``````sig
network graphics.export_svg(
    outfile: 'PathBuf',
    config: 'NetworkPlotConfig' = NetworkPlotConfig { width: 250.0, height: 300.0, delta_x: 20.0, delta_y: 20.0, offset: 30.0, radius: 3.0, fontsize: 16.0, fontface: FontFace { inner: Shared { inner: 0x64a7356cd4c0 } } },
    fit: 'bool' = false,
    label: 'Option < Template >',
    highlight: '& [usize]' = []
)
``````
===== Arguments
- #raw("outfile: 'PathBuf'") =\>
- #raw("config: 'NetworkPlotConfig' = NetworkPlotConfig { width: 250.0, height: 300.0, delta_x: 20.0, delta_y: 20.0, offset: 30.0, radius: 3.0, fontsize: 16.0, fontface: FontFace { inner: Shared { inner: 0x64a7356cd4c0 } } }") =\>
- #raw("fit: 'bool' = false") =\>
- #raw("label: 'Option < Template >'") =\>
- #raw("highlight: '& [usize]' = []") =\>
#par()[Create a SVG file with the given network structure]
==== table \_to \_svg { \#network.table \_to \_svg }
``````sig
network graphics.table_to_svg(
    outfile: 'PathBuf',
    table: 'Option < PathBuf >',
    template: 'Option < String >',
    config: 'NetworkPlotConfig' = NetworkPlotConfig { width: 250.0, height: 300.0, delta_x: 20.0, delta_y: 20.0, offset: 30.0, radius: 3.0, fontsize: 16.0, fontface: FontFace { inner: Shared { inner: 0x64a7356cd4c0 } } },
    fit: 'bool' = false,
    highlight: '& [String]' = []
)
``````
===== Arguments
- #raw("outfile: 'PathBuf'") =\>
- #raw("table: 'Option < PathBuf >'") =\>
- #raw("template: 'Option < String >'") =\>
- #raw("config: 'NetworkPlotConfig' = NetworkPlotConfig { width: 250.0, height: 300.0, delta_x: 20.0, delta_y: 20.0, offset: 30.0, radius: 3.0, fontsize: 16.0, fontface: FontFace { inner: Shared { inner: 0x64a7356cd4c0 } } }") =\>
- #raw("fit: 'bool' = false") =\>
- #raw("highlight: '& [String]' = []") =\>
#par()[Create a SVG file with the given network structure]

== Graphviz
==== save \_graphviz { \#network.save \_graphviz }
``````sig
network graphviz.save_graphviz(
    outfile: '& Path',
    name: '& str' = "network",
    global_attrs: '& str' = "",
    node_attr: 'Option < & Template >',
    edge_attr: 'Option < & Template >'
)
``````
===== Arguments
- #raw("outfile: '& Path'") =\>
- #raw("name: '& str' = \"network\"") =\>
- #raw("global_attrs: '& str' = \"\"") =\>
- #raw("node_attr: 'Option < & Template >'") =\>
- #raw("edge_attr: 'Option < & Template >'") =\>
#par()[Save the network as a graphviz file]
===== Arguments:
- #raw("outfile") - Path to the output file
- #raw("name") - Name of the graph

== HTML
==== export \_map { \#network.export \_map }
``````sig
network html.export_map(
    outfile: '& Path',
    template: 'Template',
    pagetitle: '& str' = "NADI Network",
    nodetitle: 'Template' = Template { original: "{_NAME}", parts: [Var("_NAME", "")] },
    connections: 'bool' = true
)
``````
===== Arguments
- #raw("outfile: '& Path'") =\>
- #raw("template: 'Template'") =\>
- #raw("pagetitle: '& str' = \"NADI Network\"") =\>
- #raw("nodetitle: 'Template' = Template { original: \"{_NAME}\", parts: [Var(\"_NAME\", \"\")] }") =\>
- #raw("connections: 'bool' = true") =\>
#par()[Exports the network as a HTML map]

== GIS
=== Network Functions
``````sig
network gis.gis_load_network(
    file: 'PathBuf',
    source: 'String',
    destination: 'String',
    layer: 'Option < String >',
    ignore_null: 'bool' = false
)
``````
===== Arguments
- #raw("file: 'PathBuf'") =\> GIS file to load (can be any format GDAL can understand)
- #raw("source: 'String'") =\> Field in the GIS file corresponding to the input node name
- #raw("destination: 'String'") =\> layer of the GIS file corresponding to the output node name
- #raw("layer: 'Option < String >'") =\> layer of the GIS file, first one picked by default
- #raw("ignore_null: 'bool' = false") =\> Ignore feature if it has fields with null value
#par()[Load network from a GIS file]
#par()[Loads the network from a gis file containing the edges in fields]
==== gis \_load \_attrs { \#network.gis \_load \_attrs }
``````sig
network gis.gis_load_attrs(
    file: 'PathBuf',
    node: 'String',
    layer: 'Option < String >',
    geometry: 'String' = "GEOM",
    ignore: 'String' = "",
    sanitize: 'bool' = true,
    err_no_node: 'bool' = false
)
``````
===== Arguments
- #raw("file: 'PathBuf'") =\> GIS file to load (can be any format GDAL can understand)
- #raw("node: 'String'") =\> Field in the GIS file corresponding to node name
- #raw("layer: 'Option < String >'") =\> layer of the GIS file, first one picked by default
- #raw("geometry: 'String' = \"GEOM\"") =\> Attribute to save the GIS geometry in
- #raw("ignore: 'String' = \"\"") =\> Field names separated by comma, to ignore
- #raw("sanitize: 'bool' = true") =\> sanitize the name of the fields
- #raw("err_no_node: 'bool' = false") =\> Error if all nodes are not found in the GIS file
#par()[Load node attributes from a GIS file]
#par()[The function reads a GIS file in any format (CSV, GPKG, SHP, JSON, etc) and loads their fields as attributes to the nodes.]
==== gis \_save \_connections { \#network.gis \_save \_connections }
``````sig
network gis.gis_save_connections(
    file: 'PathBuf',
    geometry: 'String',
    driver: 'Option < String >',
    layer: 'String' = "network",
    filter: 'Option < Vec < bool > >'
)
``````
===== Arguments
- #raw("file: 'PathBuf'") =\>
- #raw("geometry: 'String'") =\>
- #raw("driver: 'Option < String >'") =\>
- #raw("layer: 'String' = \"network\"") =\>
- #raw("filter: 'Option < Vec < bool > >'") =\>
#par()[Save GIS file of the connections]
==== gis \_save \_nodes { \#network.gis \_save \_nodes }
``````sig
network gis.gis_save_nodes(
    file: 'PathBuf',
    geometry: 'String',
    attrs: 'HashMap < String, String >' = {},
    driver: 'Option < String >',
    layer: 'String' = "nodes",
    filter: 'Option < Vec < bool > >'
)
``````
===== Arguments
- #raw("file: 'PathBuf'") =\>
- #raw("geometry: 'String'") =\>
- #raw("attrs: 'HashMap < String, String >' = {}") =\>
- #raw("driver: 'Option < String >'") =\>
- #raw("layer: 'String' = \"nodes\"") =\>
- #raw("filter: 'Option < Vec < bool > >'") =\>
#par()[Save GIS file of the nodes]

== Print Node
==== print \_node { \#node.print \_node }
``````sig
node print_node.print_node()
``````
===== Arguments
#par()[Print the node with its inputs and outputs]
=== Network Functions
``````sig
network print_node.print_attr_csv(*args)
``````
===== Arguments
- #raw("*args") =\>
#par()[Print the given attributes in csv format with first column with node name]

== Streamflow
==== check \_negative { \#node.check \_negative }
``````sig
node streamflow.check_negative(ts_name: '& str')
``````
===== Arguments
- #raw("ts_name: '& str'") =\> Name of the timeseries with streamflow data
#par()[Check the given streamflow timeseries for negative values]
#pagebreak(weak: true)
#pagebreak(weak: true)
#pagebreak(weak: true)
#pagebreak(weak: true)

= Developer Reference
== Data Structure
#par()[This section will describe the data structures associated with NADI system in brief.]
#par()[For more accurate and upto date details on the data structures and their available methods. Look at the API reference of #link("https://docs.rs/nadi_core/latest/nadi_core/")[#raw("nadi_core") on docs.rs].]
== Node
#par()[Points with attributes and timeseries. These can be any point as long as they'll be on the network and connection to each other.]
#par()[The attributes can be any format. There is a special type of attribute timeseries to deal with timeseries data that has been provided by the system. But users are free to make their own attributes and plugins + functions that can work with those attributes.]
#par()[Since attributes are loaded using TOML file, simple attributes can be stored and parsed from strings, moderately complex ones can be saved as a combination of array and tables, and more complex ones can be saved in different files and their path can be stored as node attributes.]
#par()[Here is an example node attribute file. Here we have string, float, int and boolean values, as well as a example csv timeseries]
``````toml
stn="smithland"
nat_7q10=12335.94850131619
orsanco_7q10=16900
lock=true

[ts.csv]
streamflow = {path="data/smithland.csv", datetime="date", data="flow"}
``````

== Network
#par()[Collection of Nodes, with Connection information. The connection information is saved in the nodes itself (=inputs= and =output= variables), but they are assigned from the network.]
#par()[The nadi system (lit, river system), is designed for the connections between points along a river. Out of different types of river networks possible, it can only handle non-branching tributaries system, where each point can have zero to multiple inputs, but can only have one output. Overall the system should have a single output point. There can be branches in the river itself in the physical sense as long as they converse before the next point of interests. There cannot be node points that have more than one path to reach another node in the representative system.]
#par()[Network file are simple text files with each edge on one line. Node names can be words with alphanumeric characters with the additional character #raw("_"), similar to how rust identifiers work. The Node names can also be quoted strings, in those cases any characters are supported inside the quotes.]
#par()[Here is an example network file,]
``````network
cannelton -> newburgh
newburgh -> evansville
evansville -> "jt-myers"
# comments are supported
"jt-myers" -> "old-shawneetown"
"old-shawneetown" -> golconda
markland -> mcalpine
golconda -> smithland
``````
#par()[Drawing it out:]
``````task
network load_file("./data/mississippi.net")
network svg_save(
   "./output/mississippi.svg",
	label="[{INDEX}] {_NAME:repl(-, ):case(title)}"
)
network clip()
!# the link path needs to be relative to this file
network echo("../output/mississippi.svg")
``````
#par()[Results:]
#par()[]
#par()[The program also plans to support the connection import from the #link("https://graphviz.org/doc/info/lang.html")[DOT format (graphviz package)].]
#par()[Network file without any connection format can be written as a node per line, but those network can only call sequential functions, and not input dependent ones.]
#par()[Depending on the use cases, it can probably be applied to other systems that are similar to a river system. Or even without the connection information, the functions that are independent to each other can be run in sequential order.]

== Timeseries
#par()[Timeseries of values, at regular interval. Can support integers, floats, booleans, strings, Arrays and Tables.]
#par()[For timeseries that are not in a format that NADI can understand. The path to the timeseries can be provided as a node attribute and plugin functions can be written to use that path to load the timeseries for the node.]

== String Templates
#par()[The templating system will be used by an external library developed by me. The library can be modified if there are specific needs for this project.]
#par()[The template system is feature rich, allowing for formatting, simple string transformations, and airthmatic calculations based on the variables (node attributes in this case). This can be used to generate file paths, and similar strings based on node attributes, as well as to format the cell values for exported table, figures, etc.]
#par()[The template library is also available for #raw("Rust"), #raw("C") and #raw("C++"), but all the interactions with the templates will be done through the #raw("nadi") interface, so that is not required.]
#par()[Documentations on the template system, can be redirected to #link("https://docs.rs/string-template-plus/latest/string_template_plus/")[the #raw("string_template_plus") library page].]
#par()[Brief explanation on the template system is given below.]
==== Template Parts
#par()[Templates have variables, time formats, expressions, and commands (disabled by default);]
``````stp
Hi, my name is {name}, my address is {address?"N/A"}.
Current time is {%H} hour  {%M} minutes.
``````
#par()[Results (with:  name=John; address=123 Road, USA):]
``````output
Hi, my name is John, my address is 123 Road, USA.
Current time is 00 hour  14 minutes.
``````
==== Optional Variables
#par()[Variables can be chained in an optional way, so the first one that's found will be used (e.g. #raw("{nickname?name}") will render nickname if it's present, else name);]
``````stp
Hi, I am {nickname?name}, my address is {address?"N/A"}.
``````
#par()[Results (with:  name=John; nickname=J; address=123 Road, USA):]
``````output
Hi, I am J, my address is 123 Road, USA.
``````
==== String Literal
#par()[Variables when replaced with literal strings (quoted strings), they will be used directly #raw("{address?\"N/A\"}") will render #raw("N/A") is #raw("address") is not present;]
``````stp
Hi, I am {nickname?name}, my address is {address?"N/A"}.
``````
#par()[Results (with:  name=John):]
``````output
Hi, I am John, my address is N/A.
``````
==== Transformers
#par()[Variables can have optional transformers which transform the string based on their rules, (e.g. float transformer will truncate the float, upcase will make the string UPPERCASE, etc.);]
``````stp
Hi, I am {nickname?name:case(up)}, my address is {address?"N/A"}.
``````
#par()[Results (with:  name=Joe):]
``````output
Hi, I am JOE, my address is N/A.
``````
==== Time formats
#par()[time formats are formatted current time (e.g. #raw("{%Y}") will become #raw("2024") as of now);]
``````stp
Today is {%B %d} of the year {%Y}.
``````
#par()[Results (with:  name=John):]
``````output
Today is June 20 of the year 2025.
``````
==== Lisp Expressions
#par()[expressions are lisp expressions that will be evaluated and the results will be used. The lisp expression can also access any variables and do any supported programming. (e.g. #raw("(+ 1 1)") in lisp will become #raw("2"));]
``````stp
guess my age(x) if: (x + 21) * 4 = =(* (+ (st+num 'age) 21) 4).
``````
#par()[Results (with:  age=20):]
``````output
guess my age(x) if: (x + 21) * 4 = 164.
``````
==== NADI Specific options
#par()[Besides the above points, specific to nadi system, any node template will have all the variables from node attributes available as strings for template. For string variables, their name can be used to access quoted string format, while their name with underscore prefix will be unquoted raw string. (e.g. if we have attribute #raw("name=\"smithland\""), then #raw("{name}") will render to #raw("\"smithland\""), while #raw("{_name}") will render to #raw("smithland")).]
#par()[Nadi system uses templates in a variety of place, and plugin functions also sometimes take templates for file path, or strings, and such things. Look at the help string of the function to see if it takes #raw("String") or #raw("Template") type.]
#par()[For example #raw("render") is a function that takes a template and prints it after rendering it for each node.]
``````task
network load_file("./data/mississippi.net")
!node[ohio] set_attrs(river="the Ohio River", streamflow=45334.12424343)
node[ohio,red] render(
	"(=(+ 1 (st+num 'INDEX))th node) {_NAME:case(title)}
	River Flow = {streamflow:calc(/10000):f(3)?\"NA\"} x 10^4"
)
``````
#par()[Results:]
``````output
{
  red = "(5th node) Red\n\tRiver Flow = NA x 10^4",
  ohio = "(6th node) Ohio\n\tRiver Flow = 4.533 x 10^4"
}
``````
#par()[As seen in above example, you can render variables, transform them, use basic calculations.]
#par()[Or you can use #raw("lisp") syntax to do more complex calculations. Refer to #link(<system-extensions>)[Nadi Extension Capabilities] section for more info on how to use #raw("lisp") on string template.]
``````task
network load_file("./data/mississippi.net")
!node[ohio] set_attrs(river="the Ohio River", streamflow=45334.12424343)
node[ohio] render(
	"{_river:case(title)} Streamflow
	from lisp = {=(/ (st+num 'streamflow) 1000):f(2)} x 10^3 cfs"
)
``````
#par()[Results:]
``````output
{
  ohio = "The Ohio River Streamflow\n\tfrom lisp = 45.33 x 10^3 cfs"
}
``````
==== Some Complex Examples
#par()[Optional variables and a command; note that commands can have variables inside them:]
``````stp
hi there, this {is?a?"test"} for $(echo a simple case {that?} {might} be "possible")
``````
#par()[Results (with:  might=may):]
``````output
hi there, this test for $(echo a simple case  may be possible)
``````
#par()[Optional variables with transformers inside command.]
``````stp
Hi {like?a?"test"} for $(this does {work:case(up)} now) (yay)
``````
#par()[Results (with:  work=Fantastic Job):]
``````output
Hi test for $(this does FANTASTIC JOB now) (yay)
``````
#par()[If you need to use #raw("{") and #raw("}") in a template, you can escape them. Following template shows how LaTeX commands can be generated from templates.]
``````stp
more {formatting?} options on {%F} and
\\latex\{command\}\{with {variable}\}, should work.
``````
#par()[Results (with:  command=Error;variable=Var):]
``````output
more  options on 2025-06-20 and
\latex{command}{with Var}, should work.
``````
#par()[This just combined a lot of different things from above:]
``````stp
let's try {every:f(2)?and?"everything"}
for $(a complex case {that?%F?} {might?be?not?found} be "possible")

see $(some-command --flag "and the value" {problem})
=(+ 1 2 (st+num 'hithere) (st+num "otherhi"))
{otherhi?=(1+ pi):f(4)}
``````
#par()[\*Error\*:]
``````error
None of the variables ["might", "be", "not", "found"] found
``````
#par()[This shows the error for the first template part that errors out, even if #raw("{problem}") will also error later, so while solving for problems in string templates, you might have to give it multiple tries.]
==== Advanced String Template with LISP
#par()[Nadi Template string is useful when you want to represent node specific string, or file path in a network. This is not as advanced as the formatted strings in python. But it can be used for complex situations based on the current functionality.]
#par()[The most important extension capability of the string template is the embedded lisp system.]
#par()[As we know, templates can render variables, and have some capacity of transforming them:]
``````stp
{name:case(title):repl(-, )} River Streamflow = {streamflow} cfs
``````
#par()[Results (with:  name=Ohio; streamflow=12000):]
``````output
Ohio River Streamflow = 12000 cfs
``````
#par()[But for numerical operation, the transformers capabilities are limited as they are made for strings.]
#par()[With lisp, we can add more logic to our templates.]
``````stp
{name:case(title):repl(-, )} River Streamflow is =(
	if (> (st+num 'streamflow) 10000)
	'Higher 'Lower
) than the threshold of 10^5 cfs.
``````
#par()[Results (with:  name=Ohio; streamflow=12000):]
``````output
Ohio River Streamflow is Higher than the threshold of 10^5 cfs.
``````
#par()[The available lisp functions are also limited, but the syntax itself gives us better airthmetic and logical calculations.]
=== Note
#par()[As the template string can get complicated, and the parsing is done through #raw("Regex"), it is not perfect. If you come across any parsing problems, please raise an issue at #link("https://github.com/Atreyagaurav/string-template-plus")[string template plus] github repo.]
=== Commands
#par()[Note that running commands within the templates is disabled for now.]
``````stp
echo today=$(date +%Y-%m-%d) {%Y-%m-%d}
``````
#par()[Results (with: ):]
``````output
echo today=$(date +%Y-%m-%d) 2025-06-20
``````
#par()[But if you are writing a command template to run in bash, then it'll be executed as the syntax is similar.]
``````task
network command("echo today=$(date +%Y-%m-%d) {%Y-%m-%d}")
``````
#par()[Results:]
``````output
$ echo today=$(date +%Y-%m-%d) 2025-06-20
``````
#par()[Here although the #raw("$(date +%Y-%m-%d)") portion was not rendered on template rendering process, the command was still valid, and was executed.]

== Tables
#par()[Tables are data types with headers and the value template. Tables can be rendered/exported into CSV, JSON, and LaTeX format. Other formats can be added later. Although tables are not exposed to the plugin system, functions to export different table formats can be written as a network function.]
#par()[A sample Table file showing two columns, left aligned name for station in title case, and right aligned columns for latitude and longitude with float value of 4 digits after decimal:]
``````table
network load_file("./data/mississippi.net")
<Name => {_NAME:repl(-, ):case(title)}
^Ind => =(+ (st+num 'INDEX) 1)
>Order => {ORDER}
^Level => {LEVEL}
# something is wrong with the set_level algorithm
# Ohio - tenessee should be level 1, and missouri/yellowstone should be 0
``````
#par()[Results:#linebreak()
|Name|Ind|Order|Level| |:---|:-:|----:|:---:| |Lower Mississippi|1|7|0| |Upper Mississippi|2|1|1| |Missouri|3|1|1| |Arkansas|4|1|1| |Red|5|1|1| |Ohio|6|2|0| |Tenessee|7|1|0|]
#par()[Here the part before #raw("=>") is the column header and the part after is the template. Presence of #raw("<") or #raw(">") in the beginning of the line makes the column left or right aligned, with center aligned (#raw("^")) by default.]
#par()[Exporting the table in svg instead of markdown allows us better network diagram.]
``````table
network load_file("./data/mississippi.net")
network echo("../output/example-table2.svg")
<Name => {_NAME:repl(-, ):case(title)}
^Ind => =(+ (st+num 'INDEX) 1)
>Order => {ORDER}
^Level => {LEVEL}
``````
#par()[\*Error\*:]
``````error
network function: "table_to_svg" not found
``````
#par()[A SVG Table can also be generated using the table file, using the task system like this:]
``````task
network load_file("./data/mississippi.net")
network table_to_svg(
	table = "./data/sample.table",
	# either table = "path/to/table", or template = "table template"
	outfile = "./output/example-table.svg",
	config = {fontsize = 16, delta_y = 20, fontface="Noto Serif"}
)
network clip()
!# the link path needs to be relative to this file
network echo("../output/example-table.svg")

``````
#par()[\*Error\*:]
``````error
network function: "table_to_svg" not found
``````

== File Templates
#par()[File templates are templates that use string templates, but they are a whole file that can be used to generate rendered text files.]
#par()[File templates also have sections which can be repeated for different nodes, with corresponding syntax.]
#par()[Following template will render a markdown table with headers and all the name and index of the nodes.]
``````stp
| Node | Index |
|------|-------|
<!-- ---8<--- -->
| {_NAME} | {INDEX} |
<!-- ---8<--- -->
``````

== Tasks
#par()[Task is a function call that the system performs. The function call can be a node function or a network function. The function can have arguments and keyword arguments that can determine its functionality. Node functions will be called on a node at a time, while the network function will be called with the whole network at once.]
#par()[Currently tasks are performed one after another. The functions that any task can use can be internal functions provided by the library or the external functions provided by the plugins.]
#par()[A sample tasks file is shown below:]
``````task
node print_attrs()
network save_graphviz("/tmp/test.gv", offset=1.3, url="{_NAME}")
node savedss(
	"natural",
	"test.dss",
	"/OHIO-RIVER/{_NAME}/01Jan1994/01Jan2012/1Day/NATURAL/"
	)
node check_sf("sf")
node.inputsfirst route_sf("observed")
node render("Node {NAME} at index {INDEX}")
``````
#par()[Here each line corresponds to one task. And if it's a node task, then it'll be called for each node (in sequential order by default). The last line #raw("node.inputsfirst") will call that function in input node before the current node. Those functions can only be called for network with an output node.]
#par()[Please note that although the string in the examples are highlighted as if they are string templates for readability. Those are just normal strings that functions take as inputs. Whether they are used as template or not depends on the individual function, refer to their help to see if they take #raw("Template") type or #raw("String") type.]

== Node Functions
#par()[Node functions are functions that take a node, and the function context to do some operations on it. They take mutable reference to the node, hence can read all node attributes, inputs, outputs, their attributes and timeseries.]
#par()[Node functions can be run from the system for all the nodes in the network in different orders.]
#par()[Currently the task system only supports running node functions for all nodes in the following 6 ways,]
- Sequential order,
- Reverse order,
- Run input nodes before the current node (recursively),
- Run output node before the current node (recursively),
- Run a list of nodes, and
- Run on a path between two nodes (inclusive).
#par()[Depending on the way the function works, it might be required to be run in a particular order. For example, a function that counts the number of dams upstream of each point, might have to be run inputs first, so that you can cumulate the number as you move downstream.]

== Network Functions
#par()[Network functions are functions that take the network as a mutable reference and run on it.]
#par()[Some examples of network functions:]
- List all the networks with their inputs/outputs,
- Checks if any nodes have some attribute larger than their output,
- Export the node attributes as a single CSV file,
- Export the nodes in LaTeX file using Tikz to draw the network,
- Calculate rmse,mse,etc errors between two attribute values for all nodes,
- Generate an interactive HTML/PDF with network information and some other template, etc.
#pagebreak(weak: true)
#pagebreak(weak: true)
#pagebreak(weak: true)
#pagebreak(weak: true)

= Developer Notes and Future Direction
== Developer Notes
#par()[This section contains my notes as I develop the NADI system. Kind of like a dev blog.]
#par()[The software package will consists of multiple components. It is planned to be designed in such a way that users can add their functionality and extend it with ease.]
#par()[Along with the Free and Open Source Software (FOSS) principles, the plugin system will make extension of the software functionality and sharing between users. As well as a way to develop in-house functionality for niche use cases.]
=== Motivation
#par()[As Hydrologist, we often deal with the data related to the points in the river. Since most of the analysis requires doing the same things in multiple points, the initial phase of data cleaning process can be automated.]
#par()[We spend a beginning phases of all projects preparing the data for analysis. And combining the time spent on visualizing the data, it's a significant chunk of our time.]
#par()[Data visualization influences the decision making from the stakeholders. And can save time by making any problems obvious from the very beginning. For examples, things like showing the quality of data (continuity for time series), interactive plots to compare data in different locations/formats, etc can help people understand their data better.]
#par()[Besides plot, the example below shows how simply adding a column with connection visual can immediately make it easier to understand the relationship between the data points in a river. Without it people need to be familiar with the names of the data points and their location, or consult a different image/map to understand the relationship.]
#par()[Table with Connection Information]
#par()[The inspiration on making this software package comes from many years of struggle with doing the same thing again and again in different projects like these. And the motivation to make something generic that can be used for plethora of projects in the future.]

=== Why Rust?
#par()[Rust^fn1 is an open source programming language that claims to be fast and memory efficient to power performance critical services. Rust is also able to integrate with other programming languages.]
#par()[Rust provides a memory safe way to do modern programming. The White House has a recent press release^fn2 about the need to have memory safe language in future softwares. The report^fn3 has following sentense about the Rust language.]
#par()[The results of the survey from stackoverflow^fn4 shows Rust has been a top choice for developers who want to use a new technology for the past 8 years, and the analysis also shows Rust is a language that generates for desire to use it once you get to know.]

=== Plugin System Experiments
#pagebreak(weak: true)
#pagebreak(weak: true)
#pagebreak(weak: true)

== Writing this Book
#par()[I'm used to #raw("emacs")'s #raw("org-mode"), where you can evaluate code and show output and all those things. Like #raw("markdown") in steroids.]
#par()[#raw("mdbook") seems to have some of those functionality in it as well. Though I think #raw("emacs")'s extension through #raw("elisp") is lot more flexible and easier to extend. #raw("mdbook") supporting custom preprocessors and renderer means we can extend it as well.]
#par()[In the process of writing this book. I made the following things.]
==== Syntax Highlight for NADI specific syntax
#par()[#raw("mdbook") uses #raw("highlight.js") to syntax highlight the code blocks in it. And since nadi system has a lot of its own syntax for string templates, task system, table system, network system etc. I wanted syntax highlight for those things. Although the attribute files are subset of #raw("TOML") format, so we have syntax highlight for it. Everything else needed a custom code.]
#par()[Following the comments in this #link("https://github.com/rust-lang/mdBook/issues/657")[github issue] led me to find a workaround for the custom syntax hightlight. I don't know for how long it will work, but this works well for now.]
#par()[Basically I am using the custom JS feature of #raw("mdbook") like:]
``````toml
[output.html]
additional-js = ["theme/syntax-highlight.js"]
``````
#par()[To insert custom highlight syntax. For example adding the syntax highlight for network text is:]
``````js
// network connections comments and node -> node syntax
hljs.registerLanguage("network", (hljs) => ({
    name: "Network",
    aliases: [ 'net' ],
    contains: [
	hljs.QUOTE_STRING_MODE,
	hljs.HASH_COMMENT_MODE,
	{
	    scope: "meta",
	    begin: '->',
	    className:"built_in",
	},
    ]
}));
``````
#par()[The syntax for network is really simple, for others (#raw("task"), #raw("table"), #raw("string-template"), etc) refer to the #raw("theme/syntax-highlight.js") file in the repository for this book.  ]
#par()[After registering all the languages, you re-initialize the #raw("highlight.js"):]
``````js
hljs.initHighlightingOnLoad();
``````
==== #raw("mdbook-nadi") preprocessor
#par()[Instead of just showing the syntax of how to use the task system, I wanted to also show the output of the examples for readers. So I started this with writing some #raw("elisp") code to run the text in selection and then copying the output to clipboard that I could paste in output block. It was really easy in emacs.]
#par()[Following code takes the selection, saves them in temporary tasks file, runs them and then puts the output in the clipboard that I can paste manually.]
``````elisp
(defun nadi-run-tasks (BEG END)
  (interactive "r")
  (let ((tasks-file (make-temp-file "tasks-")))
    (write-region BEG END tasks-file)
    (let ((output '(shell-command-to-string (format "nadi %s" tasks-file))))
	  (message output)
	  (kill-new output)
	  (delete-file tasks-file))))
``````
#par()[But this is manual process with a bit of automation. So I wanted a better solution, and that's where the #raw("mdbook") preprocessor comes in.]
#par()[With the #raw("mdbook-nadi") preprocessor, I can extract the code blocks, run it, and insert the contents just below the code block as output.]
#par()[Once I had a working prototype for this, I also started adding support for rendering string templates, and generating tables along with the task system.]
===== String templates
#par()[For string templates, write the templates in #raw("stp") blocks like below that will have the syntax hightlight.]
``````stp
Hi my name is {name}.
``````
#par()[If you add #raw("run") into it, it'll run the template with any #raw("key=val") pairs provided after run.]
#par()[Basically writing the following in the #raw("mdbook") markdown:]
``````
```stp run name=John
Hi my name is {name}.
```
``````
#par()[Will become:]
#v(1em)
#line(length: 100%)
#v(1em)``````stp
Hi my name is {name}.
``````
#par()[Results (with:  name=John):]
``````output
Hi my name is John.
``````
#v(1em)
#line(length: 100%)
#v(1em)===== Tasks
#par()[For tasks, similary write a block with #raw("task") as language. You can use #raw("!") character at the start of the line to hide it in the view. Use them for essential code that are needed for results but are not the current focus. And when you add #raw("run") it'll run and show the output.]
``````
```task run
network load_file("data/mississippi.net")
node render("Node {NAME}")
```
``````
#v(1em)
#line(length: 100%)
#v(1em)``````task
network load_file("data/mississippi.net")
node render("Node {NAME}")
``````
#par()[Results:]
``````output
{
  lower-mississippi = "Node \"lower-mississippi\"",
  upper-mississippi = "Node \"upper-mississippi\"",
  missouri = "Node \"missouri\"",
  arkansas = "Node \"arkansas\"",
  red = "Node \"red\"",
  ohio = "Node \"ohio\"",
  tenessee = "Node \"tenessee\""
}
``````
#v(1em)
#line(length: 100%)
#v(1em)===== Tables
#par()[The implementation for tables are little weird right now, but it works. Since we need to be able to load network, and perform actions before showing a table.]
#par()[So the current implementation takes the hidden lines using #raw("!")and runs them as task system, with additional task of rendering the table at the end.]
#par()[Example:]
``````
```table run markdown
network load_file("./data/mississippi.net")
<Name => {_NAME:repl(-, ):case(title)}
^Ind => =(+ (st+num 'INDEX) 1)
>Order => {ORDER}
```
``````
#par()[Becomes:]
#v(1em)
#line(length: 100%)
#v(1em)``````table
network load_file("./data/mississippi.net")
<Name => {_NAME:repl(-, ):case(title)}
^Ind => =(+ (st+num 'INDEX) 1)
>Order => {ORDER}
``````
#par()[Results:#linebreak()
|Name|Ind|Order| |:---|:-:|----:| |Lower Mississippi|1|7| |Upper Mississippi|2|1| |Missouri|3|1| |Arkansas|4|1| |Red|5|1| |Ohio|6|2| |Tenessee|7|1|]
#v(1em)
#line(length: 100%)
#v(1em)#par()[I'd like to refine this further.]
#par()[Task can be used to generate markdown in the same way as the tables can:]
#par()[For example #raw("task run") of this:]
``````task
network load_file("./data/mississippi.net")
network table_to_markdown(template="
<Name => {_NAME:repl(-, ):case(title)}
^Ind => =(+ (st+num 'INDEX) 1)
>Order => {ORDER}
")
``````
#par()[Results:]
``````output
| Name              | Ind | Order |
|:------------------|:---:|------:|
| Lower Mississippi |  1  |     7 |
| Upper Mississippi |  2  |     1 |
| Missouri          |  3  |     1 |
| Arkansas          |  4  |     1 |
| Red               |  5  |     1 |
| Ohio              |  6  |     2 |
| Tenessee          |  7  |     1 |
``````
#par()[If you do #raw("task run markdown") then:]
``````task
network load_file("./data/mississippi.net")
network table_to_markdown(template="
<Name => {_NAME:repl(-, ):case(title)}
^Ind => =(+ (st+num 'INDEX) 1)
>Order => {ORDER}
")
``````
#par()[Results:#linebreak()
|Name|Ind|Order| |:---|:-:|----:| |Lower Mississippi|1|7| |Upper Mississippi|2|1| |Missouri|3|1| |Arkansas|4|1| |Red|5|1| |Ohio|6|2| |Tenessee|7|1|]
#par()[Which means it can be used for other things:]
``````task
network load_file("./data/mississippi.net");
network echo("**Details about the Nodes:**")
network echo(render_nodes("
=(+ (st+num 'INDEX) 1). {_NAME:repl(-, ):case(title)} River
"))
``````
#par()[Results:#linebreak()
#strong[Details about the Nodes:]]
+ #par()[Lower Mississippi River]

+ #par()[Upper Mississippi River]

+ #par()[Missouri River]

+ #par()[Arkansas River]

+ #par()[Red River]

+ #par()[Ohio River]

+ #par()[Tenessee River]

#par()[You can also use the same method to insert images like this, at the end of your tasks, so that the image generated by the tasks can be inserted here.]
``````task
# do some tasks
network echo("Some other output form your tasks")
network clip()
network echo("../images/ohio-low.svg")
``````
#par()[Results:]
#par()[]
#pagebreak(weak: true)
#pagebreak(weak: true)
= Future Ideas to Implement
=== Optimization Algorithms
#par()[We can have input variables to change, and output variables to optimize, but how do we take what function to run to calculate the output variable...]
#par()[One simple idea can be to take a command template to run. So we will change the input variables, run the command for each node or network, and then that command will update the output variable that we can optimize for.]
#par()[We might require an option to call other functions in this case. Then maybe we can just pass the name of the function.]
#par()[Complex idea could be to add the support for loop syntax in task system.]

== Interactive Plots
#par()[An experiment using the #raw("cairo") graphics library shows that a PDF can be directly produced without using LaTeX as intermediate using the network information. This functionality --- although not as complete as the one in the example --- has been exposed as an internal network function for now. Further functionality related to this idea can be embedding network information in simple plots, or generate the whole plot along side the network information.]
#par()[It might be a good idea to make several functions that can export the interactive plots in LaTeX, PDF, PNG, SVG, HTML, etc. separately instead of single format.]
#par()[LaTeX and HTML will be easier due to text nature, for others I might have to spend time with some more experimentation on cairo.]
#pagebreak(weak: true)
#pagebreak(weak: true)
#pagebreak(weak: true)
